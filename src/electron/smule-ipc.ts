//    _____ ______ _   _ ______ _____         _______ ______ _____  
//   / ____|  ____| \ | |  ____|  __ \     /\|__   __|  ____|  __ \ 
//  | |  __| |__  |  \| | |__  | |__) |   /  \  | |  | |__  | |  | |
//  | | |_ |  __| | .   |  __| |  _  /   / /\ \ | |  |  __| | |  | |
//  | |__| | |____| |\  | |____| | \ \  / ____ \| |  | |____| |__| |
//   \_____|______|_| \_|______|_|  \_\/_/    \_\_|  |______|_____/ 

// This file was automatically generated by scripts/generateIPCFiles.ts
// Do not edit this file manually, as your changes will be overwritten.

import { ipcRenderer } from "electron";
export const smule = {
  /**
     * Account and auth related stuff
     */
  account: {
        /**
         * Account lookup options
         */
        lookup: {
            /**
             * Look up a user by their email
             * 
             * Usually used for login, but who cares lol
             * @param email The email adress the user utilizes for their account
             * @returns The user's data
             */
            byEmail: async (email: string): Promise<{ accountIcon: import("../api/smule-types").AccountIcon; apps: string[]; }> => await ipcRenderer.invoke("smule.account.lookup.byEmail", email),
            /**
             * Look up multiple accounts
             * @param accountIds An array of the accounts' ids
             * @returns The accounts' details
             */
            byIds: async (accountIds: number[]): Promise<import("../api/smule-types").UsersLookupResult> => await ipcRenderer.invoke("smule.account.lookup.byIds", accountIds),
            /**
             * Looks up a single account
             * @param accountId The account's id
             * @returns The account's details
             */
            byId: async (accountId: number): Promise<import("../api/smule-types").AccountIcon> => await ipcRenderer.invoke("smule.account.lookup.byId", accountId),
        },        /**
         * Logs in as a guest
         * @returns Whether or not the login was successful
         */
        loginAsGuest: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.loginAsGuest"),
        /**
         * Log into your account
         * @param email Your email address
         * @param password Your smule account's password
         * @returns Whether the log in was successful
         */
        login: async (email: string, password: string): Promise<boolean> => await ipcRenderer.invoke("smule.account.login", email, password),
        /**
         * Refreshes the session token
         * @returns Whether or not the refresh was successful
         */
        refreshLogin: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.refreshLogin"),
        /**
         * Checks if you are logged in
         * @returns Whether or not you are logged in
         */
        isLoggedIn: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.isLoggedIn"),
        /**
         * Fetches your profile
         * @returns Your profile
         */
        fetchSelf: async (): Promise<import("../api/smule-types").ProfileResult> => await ipcRenderer.invoke("smule.account.fetchSelf"),
        /**
         * Fetches the details of a specific user
         * @param accountId The id of the user to fetch
         * @returns The user's details
         */
        fetchOne: async (accountId: number): Promise<import("../api/smule-types").ProfileResult> => await ipcRenderer.invoke("smule.account.fetchOne", accountId),
    },
  /**
     * Social and chat related stuff
     */
  social: {
        /**
         * Implements SmuleChat directly in the main Smule class
         */
        chat: {
            /**
             * List with all of the event listeners
             * @see addEventListener
             */
            eventListeners: {
            },            /**
             * Creates a new spark chat
             * @param address The JID address of the chat partner
             * @param type Whether the JID address is an individual or a group
             * @returns idk
             */
            create: async (address: string, type?: "ACCT" | "GRP"): Promise<any> => await ipcRenderer.invoke("smule.social.chat.create", address, type),
            /**
             * Creates a connection to the XMPP chat server
             */
            connect: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.connect"),
            /**
             * Listen to an event
             * @param eventName The event's name
             * @param callback Your callback function
             */
            addEventListener: async (eventName: "chatstate" | "receipt" | "message" | "history" | "state" | "error", callback: (...args: any[]) => void): Promise<void> => await ipcRenderer.invoke("smule.social.chat.addEventListener", eventName, callback),
            /**
             * Removes all listeners
             */
            removeAllListeners: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.removeAllListeners"),
            /**
             * Disconnect from the XMPP chat server
             * 
             * @remarks If called when still transmitting data,
             *          it might throw an error (socket write after end).
             */
            disconnect: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.disconnect"),
            /**
             * Sends a text message
             * @param to The user to send the message to
             * @param message The message body
             */
            sendTextMessage: async (to: string | import("../api/smule-types").AccountIcon | import("../../node_modules/@types/xmpp__jid/index").JID, message: string): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendTextMessage", to, message),
            /**
             * Sends a performance / recording
             * @param to The user to send the message to
             * @param performanceKey The performance key
             */
            sendPerformanceMessage: async (to: string | import("../api/smule-types").AccountIcon | import("../../node_modules/@types/xmpp__jid/index").JID, performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendPerformanceMessage", to, performanceKey),
            /**
             * Sends a read / received receipt
             * @param to The person to inform
             */
            sendReceivedReceipt: async (to: string | import("../api/smule-types").AccountIcon | import("../../node_modules/@types/xmpp__jid/index").JID): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendReceivedReceipt", to),
            /**
             * Fetch all loaded chats
             * @returns All loaded chats
             */
            fetchChats: async (): Promise<{ [key: number]: import("../api/smule-chat-types").SmuleChatContainer; }> => await ipcRenderer.invoke("smule.social.chat.fetchChats"),
            /**
             * Fetch a specific chat
             * @param user The chat partner's user id
             * @returns The chat, or an empty new one
             */
            fetchChat: async (user: number): Promise<import("../api/smule-chat-types").SmuleChatContainer> => await ipcRenderer.invoke("smule.social.chat.fetchChat", user),
            /**
             * Loads the entire message history
             * @param limit How many messages
             * @param before Messages before this
             * @param after Messages after this
             * @param user The chat partner
             * 
             * @remarks This currently recurses until it loads ALL archived messages.
             *          This means that it will take a long time to load all messages.
             * @remarks Filtering by a specific user may not work yet
             */
            loadMessageHistory: async (limit?: number, before?: any, after?: any, user?: string | import("../../node_modules/@types/xmpp__jid/index").JID): Promise<void> => await ipcRenderer.invoke("smule.social.chat.loadMessageHistory", limit, before, after, user),
            /**
             * Sends a chat state
             * @param user The user to inform
             * @param state The state to send
             */
            sendChatState: async (user: string | import("../api/smule-types").AccountIcon | import("../../node_modules/@types/xmpp__jid/index").JID, state?: import("../api/smule-chat-types").SmulePartnerStatus): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendChatState", user, state),
            /**
             * Transform a JID into a smule user id
             * @param jid The JID itself
             * @returns The smule user id
             */
            getUserIdFromJID: async (jid: string | number): Promise<number> => await ipcRenderer.invoke("smule.social.chat.getUserIdFromJID", jid),
            /**
             * Transform a smule user id into a JID
             * @param userId The smule user id
             * @returns The JID
             */
            getJIDFromUserId: async (userId: string | number): Promise<string> => await ipcRenderer.invoke("smule.social.chat.getJIDFromUserId", userId),
        },        /**
         * Checks if you're following the specified accounts
         * @param accountIds The ids of the accounts to check
         * @returns The users you're following, and the one's you aren't
         */
        followingUsers: async (accountIds: number[]): Promise<import("../api/smule-types").FollowingResult> => await ipcRenderer.invoke("smule.social.followingUsers", accountIds),
        /**
         * Checks if you're following a specific account.
         * @param accountId The id of the account to check.
         * @returns The user you're following, and an empty array, or vice-versa
         */
        followingUser: async (accountId: number): Promise<import("../api/smule-types").FollowingResult> => await ipcRenderer.invoke("smule.social.followingUser", accountId),
        /**
         * Follows the specified users.
         * @param accountIds The ids of the accounts to follow.
         */
        followUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.followUsers", accountIds),
        /**
         * Follows a specific user.
         * @param accountId The id of the account to follow.
         */
        followUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.followUser", accountId),
        /**
         * Unfollows the specified users.
         * @param accountIds The ids of the accounts to unfollow.
         */
        unfollowUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.unfollowUsers", accountIds),
        /**
         * Unfollows a specific user.
         * @param accountId The id of the account to unfollow.
         */
        unfollowUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.unfollowUser", accountId),
        /**
         * Fetches the users that the specified user is following.
         * @param accountId The id of the user to fetch followees from.
         * @returns The users that the user is following.
         * @remarks Smule returns the ENTIRE list of followees, nonpaginated, so make sure you use it wisely
         * @remarks Followee = Following
         */
        fetchFollowings: async (accountId: number): Promise<import("../api/smule-types").FolloweeResult> => await ipcRenderer.invoke("smule.social.fetchFollowings", accountId),
        /**
         * Fetches the followers of a specific user.
         * @param accountId The id of the user whose followers are to be fetched.
         * @returns The followers of the user.
         * @remarks Smule returns the ENTIRE list of followers, nonpaginated, so make sure you use it wisely
         */
        fetchFollowers: async (accountId: number): Promise<import("../api/smule-types").FollowersResult> => await ipcRenderer.invoke("smule.social.fetchFollowers", accountId),
        /**
         * Fetches comments on a performance.
         * @param performanceKey The performance's key
         * @param offset The starting point for fetching comments. Default is 0.
         * @param limit The maximum number of comments to fetch. Default is 25.
         * @returns The comments on the performance.
         */
        fetchComments: async (performanceKey: string, offset?: number, limit?: number): Promise<import("../api/smule-types").PerformanceCommentsResult> => await ipcRenderer.invoke("smule.social.fetchComments", performanceKey, offset, limit),
        /**
         * Likes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        likeComment: async (performanceKey: string, commentKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.likeComment", performanceKey, commentKey),
        /**
         * Unlikes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        unlikeComment: async (performanceKey: string, commentKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.unlikeComment", performanceKey, commentKey),
        /**
         * Fetches the users who liked a specific comment.
         * 
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         * @returns The likes on the specified comment.
         */
        fetchCommentLikes: async (performanceKey: string, commentKey: string): Promise<import("../api/smule-types").CommentLikesResult> => await ipcRenderer.invoke("smule.social.fetchCommentLikes", performanceKey, commentKey),
        /**
         * Creates a comment on a performance.
         * @param performanceKey The key of the performance on which to comment.
         * @param comment The comment to post.
         * @param latitude The latitude to use when posting the comment.
         * @param longitude The longitude to use when posting the comment.
         * @returns The created comment's details.
         */
        createComment: async (performanceKey: string, comment: string, latitude?: number, longitude?: number): Promise<import("../api/smule-types").PerformanceCreateCommentResult> => await ipcRenderer.invoke("smule.social.createComment", performanceKey, comment, latitude, longitude),
        /**
         * Deletes multiple comments on a performance.
         * @param performanceKey The key of the performance where the comments are on.
         * @param postKeys The keys of the comments to delete.
         */
        deleteComments: async (performanceKey: string, postKeys: string[]): Promise<void> => await ipcRenderer.invoke("smule.social.deleteComments", performanceKey, postKeys),
        /**
         * Deletes a single comment on a performance.
         * @param performanceKey The key of the performance where the comment is on.
         * @param postKey The key of the comment to delete.
         */
        deleteComment: async (performanceKey: string, postKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.deleteComment", performanceKey, postKey),
        /**
         * Marks a performance as loved.
         *
         * @param performanceKey The performance's key
         */
        likePerformance: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.likePerformance", performanceKey),
        /**
         * Fetches the users that the current user has blocked.
         * @returns The blocked users.
         */
        fetchBlocked: async (): Promise<import("../api/smule-types").SocialBlockListResult> => await ipcRenderer.invoke("smule.social.fetchBlocked"),
        /**
         * Blocks the specified users.
         * @param accountIds The ids of the accounts to block.
         */
        blockUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.blockUsers", accountIds),
        /**
         * Blocks a specific user.
         * @param accountId The id of the account to block.
         */
        blockUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.blockUser", accountId),
        /**
         * Unblocks the specified users.
         * @param accountIds The ids of the accounts to unblock.
         */
        unblockUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.unblockUsers", accountIds),
        /**
         * Unblocks a specific user.
         * @param accountId The id of the account to unblock.
         */
        unblockUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.unblockUser", accountId),
        /**
         * Fetches all users that have seen your profile recently.
         * 
         * @param period The period over which to fetch the views. Defaults to "WEEK".
         * @param cursor The cursor over which to fetch views. Defaults to "start".
         * @param limit The number of views to return. Defaults to 10.
         * @returns An object containing the profile views of the current user.
         */
        fetchProfileViews: async (period?: "WEEK" | "MONTH" | "QUARTER", cursor?: string, limit?: number): Promise<import("../api/smule-types").ProfileViewsResult> => await ipcRenderer.invoke("smule.social.fetchProfileViews", period, cursor, limit),
        /**
         * Fetch performance invites "dedicated" for you.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchPersonalInvites: async (cursor?: string, limit?: number): Promise<import("../api/smule-types").InviteMeResult> => await ipcRenderer.invoke("smule.social.fetchPersonalInvites", cursor, limit),
        /**
         * Fetches a list of generic performance invites.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchInvites: async (cursor?: string, limit?: number): Promise<import("../api/smule-types").InviteListResult> => await ipcRenderer.invoke("smule.social.fetchInvites", cursor, limit),
    },
  /**
     * Songs / arrangements related stuff
     */
  songs: {
        /**
         * Fetch recommended songs, which appear on the front page
         * @param cursor Paging
         * @param limit How many per page
         * @returns The "song book"
         */
        fetchSongbook: async (cursor?: string, limit?: number): Promise<import("../api/smule-types").SongbookResult> => await ipcRenderer.invoke("smule.songs.fetchSongbook", cursor, limit),
        /**
         * Updates your songbook categories.
         * @param categoryIds The ids of the categories that you want to add to your songbook.
         * @returns The updated songbook.
         */
        updateSongbook: async (categoryIds: number[]): Promise<any> => await ipcRenderer.invoke("smule.songs.updateSongbook", categoryIds),
        /**
         * Fetch songs from a certain category
         * @param cursor Paging
         * @param categoryId The category's id
         * @param limit How many per page
         * @returns The songs
         */
        fetchFromCategory: async (cursor?: string, categoryId?: number, limit?: number, duetAccountId?: number): Promise<import("../api/smule-types").CategorySongsResult> => await ipcRenderer.invoke("smule.songs.fetchFromCategory", cursor, categoryId, limit, duetAccountId),
        /**
         * Fetches a list of song categories.
         * @param sortType The sorting order of the categories. Defaults to "POPULAR".
         * @returns The list of categories sorted by the specified type.
         */
        fetchCategoryList: async (sortType?: "POPULAR" | "ALPHA"): Promise<import("../api/smule-types").CategoryListResult> => await ipcRenderer.invoke("smule.songs.fetchCategoryList", sortType),
        /**
         * Fetches a song using the specified key.
         * 
         * @param key The song / arr key
         * @returns The details of the song
         */
        fetchOne: async (key: string): Promise<import("../api/smule-types").ArrResult> => await ipcRenderer.invoke("smule.songs.fetchOne", key),
        //TODO: raven is also sth ive seen in those official songs too
//TODO: maybe they have another specialised id?
        fetchOneFromRaven: async (ravenSongId: string): Promise<import("../api/smule-types").ArrResult> => await ipcRenderer.invoke("smule.songs.fetchOneFromRaven", ravenSongId),
        /**
         * Fetches multiple songs at once using their keys.
         * @param keys An array of song / arr keys.
         * @returns The details of the songs.
         */
        fetch: async (keys: string[]): Promise<import("../api/smule-types").ArrByKeysResult> => await ipcRenderer.invoke("smule.songs.fetch", keys),
        // TODO: test and doc
        fetchOwnedBy: async (ownerId: number, offset?: number, limit?: number): Promise<any> => await ipcRenderer.invoke("smule.songs.fetchOwnedBy", ownerId, offset, limit),
        /**
         * Bookmarks a song.
         * @param key The song / arr key.
         * @returns idk
         */
        bookmark: async (key: string): Promise<any> => await ipcRenderer.invoke("smule.songs.bookmark", key),
        /**
         * Unbookmarks a song.
         * @param key The song / arr key.
         * @returns idk
         */
        unbookmark: async (key: string): Promise<any> => await ipcRenderer.invoke("smule.songs.unbookmark", key),
        /**
         * Fetches bookmarked songs.
         * @param cursor Paging
         * @param limit The maximum number of songs to fetch
         * @returns idk prolly bookmarks
         */
        fetchBookmarks: async (cursor?: string, limit?: number): Promise<any> => await ipcRenderer.invoke("smule.songs.fetchBookmarks", cursor, limit),
        //TODO:
        update: async (key: string, artist?: string, name?: string, tags?: string[]): Promise<any> => await ipcRenderer.invoke("smule.songs.update", key, artist, name, tags),
        //TODO:
        vote: async (key: string, arrVersion: number, reason: string, vote: "UP" | "DOWN"): Promise<any> => await ipcRenderer.invoke("smule.songs.vote", key, arrVersion, reason, vote),
        //TODO:
        delete: async (key: string, deletePerformances?: boolean): Promise<any> => await ipcRenderer.invoke("smule.songs.delete", key, deletePerformances),
    },
  /**
     * Performance / recording related stuff
     */
  performances: {
        /**
         * Account lookup options
         */
        lookUp: {
            /**
             * Look up multiple performances at once
             * @param performanceKeys An array of performance keys
             * @returns The performances' details
             */
            byKeys: async (performanceKeys: string[]): Promise<import("../api/smule-types").PerformanceByKeysResult> => await ipcRenderer.invoke("smule.performances.lookUp.byKeys", performanceKeys),
            /**
             * Looks up a single performance
             * @param performanceKey The performance key
             * @returns The performance's details
             */
            byKey: async (performanceKey: string): Promise<import("../api/smule-types").PerformanceIcon> => await ipcRenderer.invoke("smule.performances.lookUp.byKey", performanceKey),
            /**
             * Look up performances by a specific user
             * @param cursor Paging
             * @param userId The user's ID
             * @param limit How many per page
             * @returns The performances
             */
            byUser: async (accountId: number, limit?: number, offset?: number): Promise<import("../api/smule-types").PerformancesByUserResult> => await ipcRenderer.invoke("smule.performances.lookUp.byUser", accountId, limit, offset),
            /**
             * Fetches performances based on the specified AV template.
             *
             * @param templateId The id of the AV template.
             * @param cursor The paging cursor. Default is "start".
             * @param limit The maximum number of performances to fetch. Default is 10.
             * @param performanceKey For some reason, a performance key? (optional)
             * @returns The performances associated with the given AV template.
             */
            byAvTemplate: async (templateId: number, cursor?: string, limit?: number, performanceKey?: string): Promise<import("../api/smule-types").PerformancesByAvTemplateResult> => await ipcRenderer.invoke("smule.performances.lookUp.byAvTemplate", templateId, cursor, limit, performanceKey),
        },        /**
         * Retrieves a list of performances based on the specified criteria.
         * 
         * @param sort The order in which to sort the performances (default is SUGGESTED).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 20).
         * @param offset The starting point for fetching performances (default is 0).
         * @returns The performances.
         */
        list: async (sort?: import("../api/smule-types").PerformancesSortOrder, fillStatus?: import("../api/smule-types").PerformancesFillStatus, limit?: number, offset?: number): Promise<import("../api/smule-types").PerformanceList> => await ipcRenderer.invoke("smule.performances.list", sort, fillStatus, limit, offset),
        /**
         * Retrieves a list of performances / recordings based on the specified criteria.
         * 
         * @param key The arr key associated with the song.
         * @param sort The order in which to sort the performances (default is RECENT).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 25).
         * @param offset The starting point for fetching performances (default is 0).
         * @param video Whether to retrieve only video performances.
         * @returns The performances.
         */
        fetchList: async (key: string, sort?: import("../api/smule-types").PerformancesSortOrder, fillStatus?: import("../api/smule-types").PerformancesFillStatus, limit?: number, offset?: number, video?: boolean): Promise<import("../api/smule-types").PerformanceList> => await ipcRenderer.invoke("smule.performances.fetchList", key, sort, fillStatus, limit, offset, video),
        /**
         * Retrieves a list of performances based on the specified criteria.
         * 
         * @param requests An array of PerformanceReq objects. Each object contains the criteria for fetching performances.
         * @returns The performance lists.
         */
        fetchLists: async (requests: import("../api/smule-types").PerformanceReq[]): Promise<{ perfLists: import("../api/smule-types").PerformanceList[]; }> => await ipcRenderer.invoke("smule.performances.fetchLists", requests),
        /**
         * Fetches a performance by its key
         * @param performanceKey The performance's key.
         * @returns The performance's details
         */
        fetchOne: async (performanceKey: string): Promise<import("../api/smule-types").PerformanceResult> => await ipcRenderer.invoke("smule.performances.fetchOne", performanceKey),
        /**
         * Fetches the performances of a specific user, sorted by the specified method with the specified fill status.
         * @param accountId The id of the user to fetch performances from
         * @param fillStatus The fill status of the performances to fetch. Default is FILLED.
         * @param sortMethod The method to sort the performances by. Default is NEWEST_FIRST.
         * @param limit The maximum number of performances to fetch. Default is 20.
         * @param offset The starting point for fetching performances. Default is 0.
         * @returns The performances of the user
         */
        fetchFromAccount: async (accountId: number, fillStatus?: import("../api/smule-types").PerformancesFillStatus, sortMethod?: import("../api/smule-types").PerformanceSortMethod, limit?: number, offset?: number): Promise<import("../api/smule-types").PerformancePartsResult> => await ipcRenderer.invoke("smule.performances.fetchFromAccount", accountId, fillStatus, sortMethod, limit, offset),
        /**
         * Fetches the children performances of a specific performance.
         * @param performanceKey The performance's key.
         * @param limit The maximum number of children performances to fetch. Default is 25.
         * @param offset The starting point for fetching children performances. Default is 0.
         * @returns The children performances of the given performance.
         */
        fetchChildren: async (performanceKey: string, limit?: number, offset?: number): Promise<import("../api/smule-types").PerformanceList> => await ipcRenderer.invoke("smule.performances.fetchChildren", performanceKey, limit, offset),
        /**
         * Fetches the details of multiple performances at once.
         * @param performanceKeys The keys of the performances to fetch.
         * @returns The details of the performances.
         */
        fetchDetails: async (performanceKeys: string[]): Promise<import("../api/smule-types").PerformanceDetailsResult> => await ipcRenderer.invoke("smule.performances.fetchDetails", performanceKeys),
        /**
         * Fetches the details of a single performance.
         * @param performanceKey The key of the performance to fetch.
         * @returns The details of the specified performance.
         */
        fetchDetailsForOne: async (performanceKey: string): Promise<import("../api/smule-types").PerformanceDetail> => await ipcRenderer.invoke("smule.performances.fetchDetailsForOne", performanceKey),
        /**
         * Uploads a performance to Smule, using the default metadata that SmuleAudio
         * generates.
         * 
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        uploadAuto: async (createRequest: import("../api/smule-requests").PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: string | Buffer, coverFile?: string | Buffer, updateThisPerformance?: any): Promise<any> => await ipcRenderer.invoke("smule.performances.uploadAuto", createRequest, uploadType, audioFile, coverFile, updateThisPerformance),
        /**
         * Uploads a performance to Smule.
         * 
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param metaFile The metadata file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        upload: async (createRequest: import("../api/smule-requests").PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: string | Buffer, metaFile: string | Buffer, coverFile?: string | Buffer, updateThisPerformance?: any): Promise<any> => await ipcRenderer.invoke("smule.performances.upload", createRequest, uploadType, audioFile, metaFile, coverFile, updateThisPerformance),
        /**
         * Deletes a performance.
         * 
         * @param performanceKey The key of the performance to be deleted.
         */
        deleteOne: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.performances.deleteOne", performanceKey),
    },
  /**
     * Search related stuff
     */
  search: {
        /**
         * Fetches the current trending searches on Smule.
         * @returns The trending searches currently available
         */
        fetchTrending: async (): Promise<import("../api/smule-types").TrendingSearchResult> => await ipcRenderer.invoke("smule.search.fetchTrending"),
        /**
         * Searches on Smule
         * @param query The query to search for
         * @returns The search result
         */
        perform: async (query: string): Promise<import("../api/smule-types").SearchResult> => await ipcRenderer.invoke("smule.search.perform", query),
        /**
         * Performs a specific search on Smule based on the provided query and parameters.
         * @param query The search term to be used in the query.
         * @param type The type of search result to be returned (e.g., song, user).
         * @param sort The sorting order of the search results (default is POPULAR).
         * @param cursor The paging cursor for the search results (default is "start").
         * @param limit The maximum number of search results to return (default is 25).
         * @returns The search results matching the specified criteria.
         */
        performSpecific: async (query: string, type: import("../api/smule-types").SearchResultType, sort?: import("../api/smule-types").SearchResultSort, cursor?: string, limit?: number): Promise<import("../api/smule-types").SearchResult> => await ipcRenderer.invoke("smule.search.performSpecific", query, type, sort, cursor, limit),
        /**
         * Gets autocomplete suggestions for a given query
         * @param query The query to get autocomplete suggestions for
         * @param limit The maximum number of suggestions to return (default is 5)
         * @returns The autocomplete suggestions
         */
        fetchAutocomplete: async (query: string, limit?: number): Promise<import("../api/smule-types").AutocompleteResult> => await ipcRenderer.invoke("smule.search.fetchAutocomplete", query, limit),
    },
  /**
     * AvTemplates related stuff
     */
  avTemplates: {
        /**
         * Fetches a list of AV templates.
         * 
         * @param limit The maximum number of AV templates to fetch. Default is 25.
         * @returns The fetched AV templates.
         */
        fetch: async (limit?: number): Promise<import("../api/smule-types").AvTemplateCategoryListResult> => await ipcRenderer.invoke("smule.avTemplates.fetch", limit),
    },
  /**
     * Telemetry stuff
     */
  telemetry: {
        /**
         * Marks a song as played.
         * 
         * @param arrKey The key associated with the song to be marked as played.
         */
        markSongAsPlayed: async (arrKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markSongAsPlayed", arrKey),
        /**
         * Marks a performance as played.
         * 
         * @param performanceKey The key associated with the performance to be marked as played.
         */
        markPerformanceAsPlayed: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markPerformanceAsPlayed", performanceKey),
        /**
         * Marks a performance as "started to be listened to" by the user.
         * This is used to track user activity and to provide recommendations.
         * @param performanceKey The key associated with the performance to be marked as listened to.
         */
        markPerformanceListenStart: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markPerformanceListenStart", performanceKey),
    },
  /**
     * Discovery / explore page stuff
     */
  explore: {
        /**
         * Explores the playlists on Smule, which are curated lists of performances.
         * @returns The playlists that match the specified criteria.
         */
        fetchPlaylists: async (): Promise<import("../api/smule-types").PlaylistExploreResult> => await ipcRenderer.invoke("smule.explore.fetchPlaylists"),
        /**
         * Fetches a playlist by its ID.
         * @param playlistId The ID of the playlist to be fetched.
         * @param offset The starting point for fetching the playlist. Default is 0.
         * @param limit The maximum number of items to fetch in the playlist. Default is 10.
         * @returns The playlist with the specified details.
         */
        fetchPlaylist: async (playlistId: number, offset?: number, limit?: number): Promise<import("../api/smule-types").PlaylistGetResult> => await ipcRenderer.invoke("smule.explore.fetchPlaylist", playlistId, offset, limit),
        /**
         * Explores the users on Smule, which can be used to discover new users.
         * @param cursor The paging cursor for the users. Default is "start", which will fetch the first 20 users.
         * @param limit The maximum number of users to fetch. Default is 20.
         * @returns The users that match the specified criteria.
         */
        fetchAccounts: async (cursor?: string, limit?: number): Promise<import("../api/smule-types").AccountExploreResult> => await ipcRenderer.invoke("smule.explore.fetchAccounts", cursor, limit),
        /**
         * Explores the groups on Smule, which are often used for collaboration.
         * @param cursor The paging cursor for the groups. Default is "start".
         * @param limit The maximum number of groups to fetch. Default is 10.
         * @param sortBy The sorting order for the groups. Default is "RECOMMENDED", which will sort by Smule's algorithmic recommendation.
         * @returns The groups matching the specified criteria.
         */
        fetchGroups: async (cursor?: string, limit?: number, sortBy?: string): Promise<import("../api/smule-types").SFAMExploreResult> => await ipcRenderer.invoke("smule.explore.fetchGroups", cursor, limit, sortBy),
        /**
         * Explores the livestreams available to the user.
         * @param cursor The starting point for fetching livestreams. Default is "start".
         * @param limit The maximum number of livestreams to fetch. Default is 20.
         * @param sort The sorting order of the livestreams. Default is "POPULAR".
         * @returns The livestreams that match the specified criteria.
         * @remarks You must be logged in and not a guest in order to explore livestreams.
         */
        fetchLivestreams: async (cursor?: string, limit?: number, sort?: string): Promise<import("../api/smule-types").CampfireExploreResult> => await ipcRenderer.invoke("smule.explore.fetchLivestreams", cursor, limit, sort),
        /**
         * Fetches the feed of the user, which contains posts and songs from the users that the user follows.
         * @param cursor The starting point for fetching feed items. Default is "start", which will fetch the first 20 items.
         * @param limit The maximum number of items to fetch. Default is 20.
         * @returns The feed items of the user.
         * @remarks You must be logged in in order to fetch your feed.
         */
        fetchFeed: async (cursor?: string, limit?: number): Promise<import("../api/smule-types").SocialFeedListResult> => await ipcRenderer.invoke("smule.explore.fetchFeed", cursor, limit),
    },
  
  settings: {
        
        fetch: async (): Promise<import("../api/smule-types").SettingsResult> => await ipcRenderer.invoke("smule.settings.fetch"),
    },
  
  TEST: {
        // this requires vip i think
// idk it gives code 1012 but also no useful data? 
        profileStats: async (): Promise<any> => await ipcRenderer.invoke("smule.TEST.profileStats"),
        
        statisticsYearly: async (): Promise<any> => await ipcRenderer.invoke("smule.TEST.statisticsYearly"),
        // this does NOTHING
        rewardCoins: async (): Promise<any> => await ipcRenderer.invoke("smule.TEST.rewardCoins"),
        // this errors out with code 1012
        inviteViaChat: async (accountIds: number[], performanceKey: string): Promise<any> => await ipcRenderer.invoke("smule.TEST.inviteViaChat", accountIds, performanceKey),
        
        fetchRecList: async (arrKey: string, topicId: number, cursor?: string, limit?: number, sort?: string): Promise<any> => await ipcRenderer.invoke("smule.TEST.fetchRecList", arrKey, topicId, cursor, limit, sort),
    },
}