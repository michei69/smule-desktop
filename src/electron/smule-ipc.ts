//    _____ ______ _   _ ______ _____         _______ ______ _____  
//   / ____|  ____| \ | |  ____|  __ \     /\|__   __|  ____|  __ \ 
//  | |  __| |__  |  \| | |__  | |__) |   /  \  | |  | |__  | |  | |
//  | | |_ |  __| | .   |  __| |  _  /   / /\ \ | |  |  __| | |  | |
//  | |__| | |____| |\  | |____| | \ \  / ____ \| |  | |____| |__| |
//   \_____|______|_| \_|______|_|  \_\/_/    \_\_|  |______|_____/ 

// This file was automatically generated by scripts/generateIPCFiles.ts
// Do not edit this file manually, as your changes will be overwritten.

import { ipcRenderer } from "electron";
export const smule = {
  /**
     * Account and auth related stuff
     */
  account: {
        /**
         * Account lookup options
         */
        lookup: {
            /**
             * Look up a user by their email
             *
             * Usually used for login, but who cares lol
             * @param email The email adress the user utilizes for their account
             * @returns The user's data
             */
            byEmail: async (email: string): Promise<{ accountIcon: import("../../node_modules/smule.js/dist/index").AccountIcon; apps: string[]; }> => await ipcRenderer.invoke("smule.account.lookup.byEmail", email),
            /**
             * Look up multiple accounts
             * @param accountIds An array of the accounts' ids
             * @returns The accounts' details
             */
            byIds: async (accountIds: number[]): Promise<import("../../node_modules/smule.js/dist/index").AccountLookupResult> => await ipcRenderer.invoke("smule.account.lookup.byIds", accountIds),
            /**
             * Looks up a single account
             * @param accountId The account's id
             * @returns The account's details
             */
            byId: async (accountId: number): Promise<import("../../node_modules/smule.js/dist/index").AccountIcon> => await ipcRenderer.invoke("smule.account.lookup.byId", accountId),
            
            byContacts: async (contacts: import("../../node_modules/smule.js/dist/index").Contact[]): Promise<import("../../node_modules/smule.js/dist/index").ContactFindResult> => await ipcRenderer.invoke("smule.account.lookup.byContacts", contacts),
        },
        /**
         * Logs in as a guest
         * @returns Whether or not the login was successful
         */
        loginAsGuest: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.loginAsGuest"),
        /**
         * Log into your account
         * @param email Your email address
         * @param password Your smule account's password
         * @returns Whether the log in was successful
         */
        login: async (email: string, password: string): Promise<boolean> => await ipcRenderer.invoke("smule.account.login", email, password),
        /**
         * Refreshes the session token
         * @returns Whether or not the refresh was successful
         */
        refreshLogin: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.refreshLogin"),
        /**
         * Checks if you are logged in
         * @returns Whether or not you are logged in
         */
        isLoggedIn: async (): Promise<boolean> => await ipcRenderer.invoke("smule.account.isLoggedIn"),
        /**
         * Fetches your profile
         * @returns Your profile
         */
        fetchSelf: async (): Promise<import("../../node_modules/smule.js/dist/index").SingUserProfileResult> => await ipcRenderer.invoke("smule.account.fetchSelf"),
        /**
         * Fetches the details of a specific user
         * @param accountId The id of the user to fetch
         * @returns The user's details
         */
        fetchOne: async (accountId: number): Promise<import("../../node_modules/smule.js/dist/index").SingUserProfileResult> => await ipcRenderer.invoke("smule.account.fetchOne", accountId),
        /**
         * Registers a new account on smule
         * @param email Your email address
         * @param password Your password
         * @returns The server response
         */
        createWithEmail: async (email: string, password: string): Promise<import("../../node_modules/smule.js/dist/index").LoginResult> => await ipcRenderer.invoke("smule.account.createWithEmail", email, password),
        /**
         * Uploads a profile picture
         * @param imageData The image data (jpeg)
         * @returns The server response
         */
        uploadProfilePicture: async (imageData: Uint8Array): Promise<import("../../node_modules/smule.js/dist/index").UserUploadPictureResult> => await ipcRenderer.invoke("smule.account.uploadProfilePicture", imageData),
        /**
         * Deletes your profile picture
         */
        deleteProfilePicture: async (): Promise<void> => await ipcRenderer.invoke("smule.account.deleteProfilePicture"),
        /**
         * Uploads a cover picture
         * @param imageData The image data
         * @remarks Requires VIP
         */
        uploadCoverPicture: async (imageData: Uint8Array): Promise<void> => await ipcRenderer.invoke("smule.account.uploadCoverPicture", imageData),
        /**
         * Deletes your cover picture
         * @remarks Requires VIP
         */
        deleteCoverPicture: async (): Promise<void> => await ipcRenderer.invoke("smule.account.deleteCoverPicture"),
        /**
         * Changes your username
         * @param username The new username
         */
        changeUsername: async (username: string): Promise<void> => await ipcRenderer.invoke("smule.account.changeUsername", username),
        /**
         * Changes your email
         * @param email The new email
         */
        changeEmail: async (email: string): Promise<void> => await ipcRenderer.invoke("smule.account.changeEmail", email),
        /**
         * Changes your bio
         * @param text The new bio
         */
        changeBio: async (text: string): Promise<void> => await ipcRenderer.invoke("smule.account.changeBio", text),
        /**
         * Customize your VIP profile
         * @param colorTheme The background and foreground colors (RRGGBB hex), and whether the text should be white or black
         * @param displayMentions Whether to display mentions
         * @param displayName Your new display name
         * @remarks Requires VIP
         */
        changeVIPProfileStuff: async (colorTheme: { background: number; foreground: number; lightText: boolean; }, displayMentions: boolean, displayName: string): Promise<void> => await ipcRenderer.invoke("smule.account.changeVIPProfileStuff", colorTheme, displayMentions, displayName),
        /**
         * Changes your full name
         * @param firstName Your first name
         * @param lastName Your last name
         */
        changeFullName: async (firstName: string, lastName: string): Promise<void> => await ipcRenderer.invoke("smule.account.changeFullName", firstName, lastName),
        /**
         * Changes your password
         * @param newPassword The new password
         */
        changePassword: async (newPassword: string): Promise<void> => await ipcRenderer.invoke("smule.account.changePassword", newPassword),
        /**
         * @returns Your preferences
         */
        fetchPreferences: async (): Promise<import("../../node_modules/smule.js/dist/index").PreferencesResult> => await ipcRenderer.invoke("smule.account.fetchPreferences"),
        /**
         * Changes your preferences
         * @param preferences The modified preferences
         */
        changePreferences: async (preferences: { name: string; value: string; }[]): Promise<void> => await ipcRenderer.invoke("smule.account.changePreferences", preferences),
        /**
         * Changes whether you wish to receive newsletter emails
         * @param consent Whether to consent
         */
        changeNewsletterConsent: async (consent: boolean): Promise<void> => await ipcRenderer.invoke("smule.account.changeNewsletterConsent", consent),
    },
  /**
     * Social and chat related stuff
     */
  social: {
        /**
         * Implements SmuleChat directly in the main Smule class
         */
        chat: {
            /**
             * Creates a new spark chat
             * @param address The JID address of the chat partner
             * @param type Whether the JID address is an individual or a group
             * @returns idk
             */
            create: async (address: string, type?: "ACCT" | "GRP"): Promise<any> => await ipcRenderer.invoke("smule.social.chat.create", address, type),
            /**
             * Creates a connection to the XMPP chat server
             */
            connect: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.connect"),
            /**
             * Listen to an event
             * @param eventName The event's name
             * @param callback Your callback function
             */
            addEventListener: async (eventName: "chatstate" | "receipt" | "message" | "history" | "state" | "error", callback: (...args: any[]) => void): Promise<void> => await ipcRenderer.invoke("smule.social.chat.addEventListener", eventName, callback),
            /**
             * Removes all listeners
             */
            removeAllListeners: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.removeAllListeners"),
            /**
             * Disconnect from the XMPP chat server
             *
             * @remarks If called when still transmitting data,
             *          it might throw an error (socket write after end).
             */
            disconnect: async (): Promise<void> => await ipcRenderer.invoke("smule.social.chat.disconnect"),
            /**
             * Sends a text message
             * @param to The user to send the message to
             * @param message The message body
             */
            sendTextMessage: async (to: any, message: string): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendTextMessage", to, message),
            /**
             * Sends a performance / recording
             * @param to The user to send the message to
             * @param performanceKey The performance key
             */
            sendPerformanceMessage: async (to: any, performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendPerformanceMessage", to, performanceKey),
            /**
             * Sends a read / received receipt
             * @param to The person to inform
             */
            sendReceivedReceipt: async (to: any): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendReceivedReceipt", to),
            /**
             * Fetch all loaded chats
             * @returns All loaded chats
             */
            fetchChats: async (): Promise<{ [key: number]: import("../../node_modules/smule.js/dist/index").SmuleChatContainer; }> => await ipcRenderer.invoke("smule.social.chat.fetchChats"),
            /**
             * Fetch a specific chat
             * @param user The chat partner's user id
             * @returns The chat, or an empty new one
             */
            fetchChat: async (user: number): Promise<import("../../node_modules/smule.js/dist/index").SmuleChatContainer> => await ipcRenderer.invoke("smule.social.chat.fetchChat", user),
            /**
             * Loads the entire message history
             * @param limit How many messages
             * @param before Messages before this
             * @param after Messages after this
             * @param user The chat partner
             *
             * @remarks This currently recurses until it loads ALL archived messages.
             *          This means that it will take a long time to load all messages.
             * @remarks Filtering by a specific user may not work yet
             */
            loadMessageHistory: async (limit?: number, before?: any, after?: any, user?: any): Promise<void> => await ipcRenderer.invoke("smule.social.chat.loadMessageHistory", limit, before, after, user),
            /**
             * Sends a chat state
             * @param user The user to inform
             * @param state The state to send
             */
            sendChatState: async (user: any, state?: import("../../node_modules/smule.js/dist/index").SmulePartnerStatus): Promise<void> => await ipcRenderer.invoke("smule.social.chat.sendChatState", user, state),
            /**
             * Transform a JID into a smule user id
             * @param jid The JID itself
             * @returns The smule user id
             */
            getUserIdFromJID: async (jid: string | number): Promise<number> => await ipcRenderer.invoke("smule.social.chat.getUserIdFromJID", jid),
            /**
             * Transform a smule user id into a JID
             * @param userId The smule user id
             * @returns The JID
             */
            getJIDFromUserId: async (userId: string | number): Promise<string> => await ipcRenderer.invoke("smule.social.chat.getJIDFromUserId", userId),
        },
        /**
         * Checks if you're following the specified accounts
         * @param accountIds The ids of the accounts to check
         * @returns The users you're following, and the one's you aren't
         */
        isFollowingUsers: async (accountIds: number[]): Promise<import("../../node_modules/smule.js/dist/index").SocialIsFollowingResult> => await ipcRenderer.invoke("smule.social.isFollowingUsers", accountIds),
        /**
         * Checks if you're following a specific account.
         * @param accountId The id of the account to check.
         * @returns The user you're following, and an empty array, or vice-versa
         */
        isFollowingUser: async (accountId: number): Promise<import("../../node_modules/smule.js/dist/index").SocialIsFollowingResult> => await ipcRenderer.invoke("smule.social.isFollowingUser", accountId),
        /**
         * Follows the specified users.
         * @param accountIds The ids of the accounts to follow.
         */
        followUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.followUsers", accountIds),
        /**
         * Follows a specific user.
         * @param accountId The id of the account to follow.
         */
        followUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.followUser", accountId),
        /**
         * Unfollows the specified users.
         * @param accountIds The ids of the accounts to unfollow.
         */
        unfollowUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.unfollowUsers", accountIds),
        /**
         * Unfollows a specific user.
         * @param accountId The id of the account to unfollow.
         */
        unfollowUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.unfollowUser", accountId),
        /**
         * Fetches the users that the specified user is following.
         * @param accountId The id of the user to fetch followees from.
         * @returns The users that the user is following.
         * @remarks Smule returns the ENTIRE list of followees, nonpaginated, so make sure you use it wisely
         * @remarks Followee = Following
         */
        fetchFollowings: async (accountId: number): Promise<import("../../node_modules/smule.js/dist/index").SocialFolloweesResult> => await ipcRenderer.invoke("smule.social.fetchFollowings", accountId),
        /**
         * Fetches the followers of a specific user.
         * @param accountId The id of the user whose followers are to be fetched.
         * @returns The followers of the user.
         * @remarks Smule returns the ENTIRE list of followers, nonpaginated, so make sure you use it wisely
         */
        fetchFollowers: async (accountId: number): Promise<import("../../node_modules/smule.js/dist/index").SocialFollowersResult> => await ipcRenderer.invoke("smule.social.fetchFollowers", accountId),
        /**
         * Fetches comments on a performance.
         * @param performanceKey The performance's key
         * @param offset The starting point for fetching comments. Default is 0.
         * @param limit The maximum number of comments to fetch. Default is 25.
         * @returns The comments on the performance.
         */
        fetchComments: async (performanceKey: string, offset?: number, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformanceCommentsResult> => await ipcRenderer.invoke("smule.social.fetchComments", performanceKey, offset, limit),
        /**
         * Likes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        likeComment: async (performanceKey: string, commentKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.likeComment", performanceKey, commentKey),
        /**
         * Unlikes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        unlikeComment: async (performanceKey: string, commentKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.unlikeComment", performanceKey, commentKey),
        /**
         * Fetches the users who liked a specific comment.
         *
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         * @returns The likes on the specified comment.
         */
        fetchCommentLikes: async (performanceKey: string, commentKey: string): Promise<import("../../node_modules/smule.js/dist/index").SocialCommentLikesResult> => await ipcRenderer.invoke("smule.social.fetchCommentLikes", performanceKey, commentKey),
        /**
         * Creates a comment on a performance.
         * @param performanceKey The key of the performance on which to comment.
         * @param comment The comment to post.
         * @param latitude The latitude to use when posting the comment.
         * @param longitude The longitude to use when posting the comment.
         * @returns The created comment's details.
         */
        createComment: async (performanceKey: string, comment: string, latitude?: number, longitude?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformanceCreateCommentResult> => await ipcRenderer.invoke("smule.social.createComment", performanceKey, comment, latitude, longitude),
        /**
         * Deletes multiple comments on a performance.
         * @param performanceKey The key of the performance where the comments are on.
         * @param postKeys The keys of the comments to delete.
         */
        deleteComments: async (performanceKey: string, postKeys: string[]): Promise<void> => await ipcRenderer.invoke("smule.social.deleteComments", performanceKey, postKeys),
        /**
         * Deletes a single comment on a performance.
         * @param performanceKey The key of the performance where the comment is on.
         * @param postKey The key of the comment to delete.
         */
        deleteComment: async (performanceKey: string, postKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.deleteComment", performanceKey, postKey),
        /**
         * Marks a performance as loved.
         *
         * @param performanceKey The performance's key
         */
        likePerformance: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.social.likePerformance", performanceKey),
        /**
         * Fetches the users that the current user has blocked.
         * @returns The blocked users.
         */
        fetchBlocked: async (): Promise<import("../../node_modules/smule.js/dist/index").SocialBlockListResult> => await ipcRenderer.invoke("smule.social.fetchBlocked"),
        /**
         * Blocks the specified users.
         * @param accountIds The ids of the accounts to block.
         */
        blockUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.blockUsers", accountIds),
        /**
         * Blocks a specific user.
         * @param accountId The id of the account to block.
         */
        blockUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.blockUser", accountId),
        /**
         * Unblocks the specified users.
         * @param accountIds The ids of the accounts to unblock.
         */
        unblockUsers: async (accountIds: number[]): Promise<void> => await ipcRenderer.invoke("smule.social.unblockUsers", accountIds),
        /**
         * Unblocks a specific user.
         * @param accountId The id of the account to unblock.
         */
        unblockUser: async (accountId: number): Promise<void> => await ipcRenderer.invoke("smule.social.unblockUser", accountId),
        /**
         * Fetches all users that have seen your profile recently.
         *
         * @param period The period over which to fetch the views. Defaults to "WEEK".
         * @param cursor The cursor over which to fetch views. Defaults to "start".
         * @param limit The number of views to return. Defaults to 10.
         * @returns An object containing the profile views of the current user.
         */
        fetchProfileViews: async (period?: "WEEK" | "MONTH" | "QUARTER", cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").AccountProfileStatsViewsResult> => await ipcRenderer.invoke("smule.social.fetchProfileViews", period, cursor, limit),
        /**
         * Fetch performance invites "dedicated" for you.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchPersonalInvites: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").InviteMeResult> => await ipcRenderer.invoke("smule.social.fetchPersonalInvites", cursor, limit),
        /**
         * Fetches a list of generic performance invites.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchInvites: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").InviteListResult> => await ipcRenderer.invoke("smule.social.fetchInvites", cursor, limit),
    },
  /**
     * Songs / arrangements related stuff
     */
  songs: {
        /**
         * Fetch recommended songs, which appear on the front page
         * @param cursor Paging
         * @param limit How many per page
         * @returns The "song book"
         */
        fetchSongbook: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").SongbookResult> => await ipcRenderer.invoke("smule.songs.fetchSongbook", cursor, limit),
        /**
         * Updates your songbook categories.
         * @param categoryIds The ids of the categories that you want to add to your songbook.
         * @returns The updated songbook.
         */
        updateSongbook: async (categoryIds: number[]): Promise<any> => await ipcRenderer.invoke("smule.songs.updateSongbook", categoryIds),
        /**
         * Fetch songs from a certain category
         * @param cursor Paging
         * @param categoryId The category's id
         * @param limit How many per page
         * @returns The songs
         */
        fetchFromCategory: async (cursor?: string, categoryId?: number, limit?: number, duetAccountId?: number): Promise<import("../../node_modules/smule.js/dist/index").CategorySongsResult> => await ipcRenderer.invoke("smule.songs.fetchFromCategory", cursor, categoryId, limit, duetAccountId),
        /**
         * Fetches a list of song categories.
         * @param sortType The sorting order of the categories. Defaults to "POPULAR".
         * @returns The list of categories sorted by the specified type.
         */
        fetchCategoryList: async (sortType?: "POPULAR" | "ALPHA"): Promise<import("../../node_modules/smule.js/dist/index").CategoryListResult> => await ipcRenderer.invoke("smule.songs.fetchCategoryList", sortType),
        /**
         * Fetches a song using the specified key.
         *
         * @param key The song / arr key
         * @returns The details of the song
         */
        fetchOne: async (key: string): Promise<import("../../node_modules/smule.js/dist/index").ArrResult> => await ipcRenderer.invoke("smule.songs.fetchOne", key),
        
        fetchOneFromRaven: async (ravenSongId: string): Promise<import("../../node_modules/smule.js/dist/index").ArrResult> => await ipcRenderer.invoke("smule.songs.fetchOneFromRaven", ravenSongId),
        /**
         * Fetches multiple songs at once using their keys.
         * @param keys An array of song / arr keys.
         * @returns The details of the songs.
         */
        fetch: async (keys: string[]): Promise<import("../../node_modules/smule.js/dist/index").ArrByKeysResult> => await ipcRenderer.invoke("smule.songs.fetch", keys),
        
        fetchOwnedBy: async (ownerId: number, offset?: number, limit?: number): Promise<any> => await ipcRenderer.invoke("smule.songs.fetchOwnedBy", ownerId, offset, limit),
        /**
         * Fetches free songs from a list of genres
         *
         * This endpoint is usually used at register, to recommend
         * some songs to the new user.
         * @param genreIds The ids of the genres
         * @returns A stupid nested list with free "compositions"
         */
        fetchFromGenres: async (genreIds: number[]): Promise<import("../../node_modules/smule.js/dist/index").TopicOptionResult> => await ipcRenderer.invoke("smule.songs.fetchFromGenres", genreIds),
        /**
         * Fetches the lyrics and pitches for a certain arrangement
         * @param key The song / arr key
         * @returns The lyrics, their type, and the pitches
         */
        fetchLyricsAndPitches: async (key: string): Promise<{ lyrics: import("../../node_modules/smule.js/dist/index").SmuleLyric[]; pitches: import("../../node_modules/smule.js/dist/index").SmulePitchesData; type: "RAVEN" | "COMMUNITY"; }> => await ipcRenderer.invoke("smule.songs.fetchLyricsAndPitches", key),
        /**
         * Bookmarks a song.
         * @param key The song / arr key.
         */
        bookmark: async (key: string): Promise<void> => await ipcRenderer.invoke("smule.songs.bookmark", key),
        /**
         * Unbookmarks a song.
         * @param key The song / arr key.
         */
        unbookmark: async (key: string): Promise<void> => await ipcRenderer.invoke("smule.songs.unbookmark", key),
        /**
         * Fetches bookmarked songs.
         * @param cursor Paging
         * @param limit The maximum number of songs to fetch
         * @returns idk prolly bookmarks
         */
        fetchBookmarks: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").ArrBookmarkListResult> => await ipcRenderer.invoke("smule.songs.fetchBookmarks", cursor, limit),
        
        update: async (key: string, artist?: string, name?: string, tags?: string[]): Promise<any> => await ipcRenderer.invoke("smule.songs.update", key, artist, name, tags),
        
        vote: async (key: string, arrVersion: number, reason: string, vote: "UP" | "DOWN"): Promise<any> => await ipcRenderer.invoke("smule.songs.vote", key, arrVersion, reason, vote),
        
        delete: async (key: string, deletePerformances?: boolean): Promise<any> => await ipcRenderer.invoke("smule.songs.delete", key, deletePerformances),
    },
  /**
     * Performance / recording related stuff
     */
  performances: {
        /**
         * Account lookup options
         */
        lookUp: {
            /**
             * Look up multiple performances at once
             * @param performanceKeys An array of performance keys
             * @returns The performances' details
             */
            byKeys: async (performanceKeys: string[]): Promise<import("../../node_modules/smule.js/dist/index").PerformanceByKeysResult> => await ipcRenderer.invoke("smule.performances.lookUp.byKeys", performanceKeys),
            /**
             * Looks up a single performance
             * @param performanceKey The performance key
             * @returns The performance's details
             */
            byKey: async (performanceKey: string): Promise<import("../../node_modules/smule.js/dist/index").PerformanceIcon> => await ipcRenderer.invoke("smule.performances.lookUp.byKey", performanceKey),
            /**
             * Look up performances by a specific user
             * @param cursor Paging
             * @param userId The user's ID
             * @param limit How many per page
             * @returns The performances
             */
            byUser: async (accountId: number, fillStatus?: import("../../node_modules/smule.js/dist/index").PerformancesFillStatus, sortMethod?: import("../../node_modules/smule.js/dist/index").PerformanceSortMethod, limit?: number, offset?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformancesByUserResult> => await ipcRenderer.invoke("smule.performances.lookUp.byUser", accountId, fillStatus, sortMethod, limit, offset),
            /**
             * Fetches performances based on the specified AV template.
             *
             * @param templateId The id of the AV template.
             * @param cursor The paging cursor. Default is "start".
             * @param limit The maximum number of performances to fetch. Default is 10.
             * @param performanceKey For some reason, a performance key? (optional)
             * @returns The performances associated with the given AV template.
             */
            byAvTemplate: async (templateId: number, cursor?: string, limit?: number, performanceKey?: string): Promise<import("../../node_modules/smule.js/dist/index").PerformancesByAvTemplateResult> => await ipcRenderer.invoke("smule.performances.lookUp.byAvTemplate", templateId, cursor, limit, performanceKey),
            /**
             * Fetches performances based on the specified genre.
             * @param genreId The id of the genre
             * @param offset The starting point
             * @param limit The maximum number of performances
             * @param fillStatus Type of performances
             * @param sort The order
             * @returns The performances
             */
            byGenre: async (genreId: number, offset?: number, limit?: number, fillStatus?: import("../../node_modules/smule.js/dist/index").PerformancesFillStatus, sort?: import("../../node_modules/smule.js/dist/index").PerformancesSortOrder): Promise<import("../../node_modules/smule.js/dist/index").PerformanceList> => await ipcRenderer.invoke("smule.performances.lookUp.byGenre", genreId, offset, limit, fillStatus, sort),
        },
        /**
         * Retrieves a list of performances based on the specified criteria.
         *
         * @param sort The order in which to sort the performances (default is SUGGESTED).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 20).
         * @param offset The starting point for fetching performances (default is 0).
         * @returns The performances.
         */
        list: async (sort?: import("../../node_modules/smule.js/dist/index").PerformancesSortOrder, fillStatus?: import("../../node_modules/smule.js/dist/index").PerformancesFillStatus, limit?: number, offset?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformanceList> => await ipcRenderer.invoke("smule.performances.list", sort, fillStatus, limit, offset),
        /**
         * Retrieves a list of performances / recordings based on the specified criteria.
         *
         * @param key The arr key associated with the song.
         * @param sort The order in which to sort the performances (default is RECENT).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 25).
         * @param offset The starting point for fetching performances (default is 0).
         * @param video Whether to retrieve only video performances.
         * @returns The performances.
         */
        fetchList: async (key: string, sort?: import("../../node_modules/smule.js/dist/index").PerformancesSortOrder, fillStatus?: import("../../node_modules/smule.js/dist/index").PerformancesFillStatus, limit?: number, offset?: number, video?: boolean): Promise<import("../../node_modules/smule.js/dist/index").PerformanceList> => await ipcRenderer.invoke("smule.performances.fetchList", key, sort, fillStatus, limit, offset, video),
        /**
         * Retrieves a list of performances based on the specified criteria.
         *
         * @param requests An array of PerformanceReq objects. Each object contains the criteria for fetching performances.
         * @returns The performance lists.
         */
        fetchLists: async (requests: import("../../node_modules/smule.js/dist/index").PerformanceReq[]): Promise<{ perfLists: import("../../node_modules/smule.js/dist/index").PerformanceList[]; }> => await ipcRenderer.invoke("smule.performances.fetchLists", requests),
        /**
         * Fetches a performance by its key
         * @param performanceKey The performance's key.
         * @returns The performance's details
         */
        fetchOne: async (performanceKey: string): Promise<import("../../node_modules/smule.js/dist/index").PerformanceResult> => await ipcRenderer.invoke("smule.performances.fetchOne", performanceKey),
        /**
         * Fetches the performances of a specific user, sorted by the specified method with the specified fill status.
         * @param accountId The id of the user to fetch performances from
         * @param fillStatus The fill status of the performances to fetch. Default is FILLED.
         * @param sortMethod The method to sort the performances by. Default is NEWEST_FIRST.
         * @param limit The maximum number of performances to fetch. Default is 20.
         * @param offset The starting point for fetching performances. Default is 0.
         * @returns The performances of the user
         */
        fetchFromAccount: async (accountId: number, fillStatus?: import("../../node_modules/smule.js/dist/index").PerformancesFillStatus, sortMethod?: import("../../node_modules/smule.js/dist/index").PerformanceSortMethod, limit?: number, offset?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformancePartsResult> => await ipcRenderer.invoke("smule.performances.fetchFromAccount", accountId, fillStatus, sortMethod, limit, offset),
        
        fetchBookmarkedInvites: async (offset?: number, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformanceBookmarkSeedResult> => await ipcRenderer.invoke("smule.performances.fetchBookmarkedInvites", offset, limit),
        /**
         * Fetches the children performances of a specific performance.
         * @param performanceKey The performance's key.
         * @param limit The maximum number of children performances to fetch. Default is 25.
         * @param offset The starting point for fetching children performances. Default is 0.
         * @returns The children performances of the given performance.
         */
        fetchChildren: async (performanceKey: string, limit?: number, offset?: number): Promise<import("../../node_modules/smule.js/dist/index").PerformanceList> => await ipcRenderer.invoke("smule.performances.fetchChildren", performanceKey, limit, offset),
        /**
         * Fetches the details of multiple performances at once.
         * @param performanceKeys The keys of the performances to fetch.
         * @returns The details of the performances.
         */
        fetchDetails: async (performanceKeys: string[]): Promise<import("../../node_modules/smule.js/dist/index").PerformanceDetailsResult> => await ipcRenderer.invoke("smule.performances.fetchDetails", performanceKeys),
        /**
         * Fetches the details of a single performance.
         * @param performanceKey The key of the performance to fetch.
         * @returns The details of the specified performance.
         */
        fetchDetailsForOne: async (performanceKey: string): Promise<import("../../node_modules/smule.js/dist/index").PerformanceDetail> => await ipcRenderer.invoke("smule.performances.fetchDetailsForOne", performanceKey),
        /**
         * Uploads a performance to Smule, using the default metadata that SmuleAudio
         * generates.
         *
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        uploadAuto: async (createRequest: import("../../node_modules/smule.js/dist/index").PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: string | Buffer, coverFile?: string | Buffer, updateThisPerformance?: any): Promise<any> => await ipcRenderer.invoke("smule.performances.uploadAuto", createRequest, uploadType, audioFile, coverFile, updateThisPerformance),
        /**
         * Uploads a performance to Smule.
         *
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param metaFile The metadata file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        upload: async (createRequest: import("../../node_modules/smule.js/dist/index").PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: string | Buffer, metaFile: string | Buffer, coverFile?: string | Buffer, updateThisPerformance?: any): Promise<any> => await ipcRenderer.invoke("smule.performances.upload", createRequest, uploadType, audioFile, metaFile, coverFile, updateThisPerformance),
        /**
         * Deletes a performance.
         *
         * @param performanceKey The key of the performance to be deleted.
         */
        deleteOne: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.performances.deleteOne", performanceKey),
        
        bookmarkInvites: async (performanceKeys: string[]): Promise<void> => await ipcRenderer.invoke("smule.performances.bookmarkInvites", performanceKeys),
        
        unbookmarkInvites: async (performanceKeys: string[]): Promise<void> => await ipcRenderer.invoke("smule.performances.unbookmarkInvites", performanceKeys),
    },
  /**
     * Search related stuff
     */
  search: {
        /**
         * Fetches the current trending searches on Smule.
         * @returns The trending searches currently available
         */
        fetchTrending: async (): Promise<import("../../node_modules/smule.js/dist/index").RecTrendingSearchResult> => await ipcRenderer.invoke("smule.search.fetchTrending"),
        /**
         * Searches on Smule
         * @param query The query to search for
         * @returns The search result
         */
        perform: async (query: string): Promise<import("../../node_modules/smule.js/dist/index").SearchResult> => await ipcRenderer.invoke("smule.search.perform", query),
        /**
         * Performs a specific search on Smule based on the provided query and parameters.
         * @param query The search term to be used in the query.
         * @param type The type of search result to be returned (e.g., song, user).
         * @param sort The sorting order of the search results (default is POPULAR).
         * @param cursor The paging cursor for the search results (default is "start").
         * @param limit The maximum number of search results to return (default is 25).
         * @returns The search results matching the specified criteria.
         */
        performSpecific: async (query: string, type: import("../../node_modules/smule.js/dist/index").SearchResultType, sort?: import("../../node_modules/smule.js/dist/index").SearchResultSort, cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").SearchResult> => await ipcRenderer.invoke("smule.search.performSpecific", query, type, sort, cursor, limit),
        /**
         * Gets autocomplete suggestions for a given query
         * @param query The query to get autocomplete suggestions for
         * @param limit The maximum number of suggestions to return (default is 5)
         * @returns The autocomplete suggestions
         */
        fetchAutocomplete: async (query: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").SearchAutocompleteResult> => await ipcRenderer.invoke("smule.search.fetchAutocomplete", query, limit),
    },
  /**
     * AvTemplates related stuff
     */
  avTemplates: {
        /**
         * Fetches a list of AV templates.
         *
         * @param limit The maximum number of AV templates to fetch. Default is 25.
         * @returns The fetched AV templates.
         */
        fetch: async (limit?: number): Promise<import("../../node_modules/smule.js/dist/index").AvTemplateCategoryListResult> => await ipcRenderer.invoke("smule.avTemplates.fetch", limit),
    },
  /**
     * Telemetry stuff
     */
  telemetry: {
        /**
         * Marks a song as played.
         *
         * @param arrKey The key associated with the song to be marked as played.
         */
        markSongAsPlayed: async (arrKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markSongAsPlayed", arrKey),
        /**
         * Marks a performance as played.
         *
         * @param performanceKey The key associated with the performance to be marked as played.
         */
        markPerformanceAsPlayed: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markPerformanceAsPlayed", performanceKey),
        /**
         * Marks a performance as "started to be listened to" by the user.
         * This is used to track user activity and to provide recommendations.
         * @param performanceKey The key associated with the performance to be marked as listened to.
         */
        markPerformanceListenStart: async (performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.telemetry.markPerformanceListenStart", performanceKey),
    },
  /**
     * Discovery / explore page stuff
     */
  explore: {
        /**
         * Explores the playlists on Smule, which are curated lists of performances.
         * @returns The playlists that match the specified criteria.
         */
        fetchPlaylists: async (): Promise<import("../../node_modules/smule.js/dist/index").PlaylistExploreResult> => await ipcRenderer.invoke("smule.explore.fetchPlaylists"),
        /**
         * Fetches a playlist by its ID.
         * @param playlistId The ID of the playlist to be fetched.
         * @param offset The starting point for fetching the playlist. Default is 0.
         * @param limit The maximum number of items to fetch in the playlist. Default is 10.
         * @returns The playlist with the specified details.
         */
        fetchPlaylist: async (playlistId: number, offset?: number, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").PlaylistGetResult> => await ipcRenderer.invoke("smule.explore.fetchPlaylist", playlistId, offset, limit),
        /**
         * Explores the users on Smule, which can be used to discover new users.
         * @param cursor The paging cursor for the users. Default is "start", which will fetch the first 20 users.
         * @param limit The maximum number of users to fetch. Default is 20.
         * @returns The users that match the specified criteria.
         */
        fetchAccounts: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").AccountExploreResult> => await ipcRenderer.invoke("smule.explore.fetchAccounts", cursor, limit),
        
        fetchRecommendedAccounts: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").AccountExploreResult> => await ipcRenderer.invoke("smule.explore.fetchRecommendedAccounts", cursor, limit),
        /**
         * Explores the groups on Smule, which are often used for collaboration.
         * @param cursor The paging cursor for the groups. Default is "start".
         * @param limit The maximum number of groups to fetch. Default is 10.
         * @param sortBy The sorting order for the groups. Default is "RECOMMENDED", which will sort by Smule's algorithmic recommendation.
         * @returns The groups matching the specified criteria.
         */
        fetchGroups: async (cursor?: string, limit?: number, sortBy?: string): Promise<import("../../node_modules/smule.js/dist/index").SFamListResult> => await ipcRenderer.invoke("smule.explore.fetchGroups", cursor, limit, sortBy),
        /**
         * Explores the livestreams available to the user.
         * @param cursor The starting point for fetching livestreams. Default is "start".
         * @param limit The maximum number of livestreams to fetch. Default is 20.
         * @param sort The sorting order of the livestreams. Default is "POPULAR".
         * @returns The livestreams that match the specified criteria.
         * @remarks You must be logged in and not a guest in order to explore livestreams.
         */
        fetchLivestreams: async (cursor?: string, limit?: number, sort?: string): Promise<import("../../node_modules/smule.js/dist/index").CampfireListResult> => await ipcRenderer.invoke("smule.explore.fetchLivestreams", cursor, limit, sort),
        /**
         * Fetches the feed of the user, which contains posts and songs from the users that the user follows.
         * @param cursor The starting point for fetching feed items. Default is "start", which will fetch the first 20 items.
         * @param limit The maximum number of items to fetch. Default is 20.
         * @returns The feed items of the user.
         * @remarks You must be logged in in order to fetch your feed.
         */
        fetchFeed: async (cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").SocialFeedListResult> => await ipcRenderer.invoke("smule.explore.fetchFeed", cursor, limit),
        /**
         * Fetches a list of genres
         * @param cursor The offset to start from
         * @param limit The number of genres to fetch
         * @returns A list of genres
         */
        fetchGenres: async (cursor?: number, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").TopicOptionResult> => await ipcRenderer.invoke("smule.explore.fetchGenres", cursor, limit),
        /**
         * Fetches your selected genres
         * @returns A list of genres
         */
        fetchYourGenres: async (): Promise<import("../../node_modules/smule.js/dist/index").TopicOptionResult> => await ipcRenderer.invoke("smule.explore.fetchYourGenres"),
    },
  
  settings: {
        
        fetch: async (): Promise<import("../../node_modules/smule.js/dist/index").SettingsResult> => await ipcRenderer.invoke("smule.settings.fetch"),
    },
  
  live: {
        /**
         * Implements SmuleChat directly in the main Smule class for livestreams
         */
        chat: {
            /**
             * Creates a connection to the XMPP chat server
             */
            connect: async (host: string, cfireJID: string): Promise<void> => await ipcRenderer.invoke("smule.live.chat.connect", host, cfireJID),
            /**
             * Listen to an event
             * @param eventName The event's name
             * @param callback Your callback function
             */
            addEventListener: async (eventName: "message" | "history" | "state" | "error" | "performance-start" | "create-mic-request" | "cancel-mic-request" | "presence" | "gift-sent" | "new-host" | "host-left", callback: (...args: any[]) => void): Promise<void> => await ipcRenderer.invoke("smule.live.chat.addEventListener", eventName, callback),
            /**
             * Removes all listeners
             */
            removeAllListeners: async (): Promise<void> => await ipcRenderer.invoke("smule.live.chat.removeAllListeners"),
            /**
             * Disconnect from the XMPP chat server
             *
             * @remarks If called when still transmitting data,
             *          it might throw an error (socket write after end).
             */
            disconnect: async (): Promise<void> => await ipcRenderer.invoke("smule.live.chat.disconnect"),
            /**
             * Sends a text message
             * @param to The user to send the message to
             * @param message The message body
             */
            sendTextMessage: async (to: any, message: string): Promise<void> => await ipcRenderer.invoke("smule.live.chat.sendTextMessage", to, message),
            /**
             * Fetch all loaded chats
             * @returns All loaded chats
             */
            fetchChat: async (): Promise<import("../../node_modules/smule.js/dist/index").SmuleChatContainer> => await ipcRenderer.invoke("smule.live.chat.fetchChat"),
            
            fetchUsers: async (): Promise<any[]> => await ipcRenderer.invoke("smule.live.chat.fetchUsers"),
            /**
             * Loads the entire message history
             * @param limit How many messages
             * @param before Messages before this
             * @param after Messages after this
             * @param user The chat partner
             *
             * @remarks This currently recurses until it loads ALL archived messages.
             *          This means that it will take a long time to load all messages.
             * @remarks Filtering by a specific user may not work yet
             */
            loadMessageHistory: async (limit?: number, before?: any, after?: any, user?: any): Promise<void> => await ipcRenderer.invoke("smule.live.chat.loadMessageHistory", limit, before, after, user),
        },
        
        fetch: async (campfireId: number): Promise<import("../../node_modules/smule.js/dist/index").CampfireSyncResult> => await ipcRenderer.invoke("smule.live.fetch", campfireId),
    },
  
  groups: {
        /**
         * Fetches a group's details
         * @param groupId The ID of the group
         * @returns The group
         */
        fetchOne: async (groupId: number): Promise<import("../../node_modules/smule.js/dist/index").SFamInfoResult> => await ipcRenderer.invoke("smule.groups.fetchOne", groupId),
        /**
         * Fetches a group's posts
         * @param groupId The ID of the group
         * @param cursor The starting point
         * @param limit How many to fetch
         * @returns The posts
         */
        fetchPosts: async (groupId: number, cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").SocialFeedListResult> => await ipcRenderer.invoke("smule.groups.fetchPosts", groupId, cursor, limit),
        /**
         * Fetches a group's members
         * @param groupId The ID of the group
         * @param cursor Starting point
         * @param limit How many
         * @param roles Member roles (0 - owner, 1 - admin, 2 - member)
         * @returns The members
         */
        fetchMembers: async (groupId: number, cursor?: string, limit?: number, roles?: number[]): Promise<import("../../node_modules/smule.js/dist/index").SFamMemberListResult> => await ipcRenderer.invoke("smule.groups.fetchMembers", groupId, cursor, limit, roles),
        /**
         * Sends a request to join a group
         * @param groupId The ID of the group
         * @returns The membership status
         */
        join: async (groupId: number): Promise<import("../../node_modules/smule.js/dist/index").SFamMembershipType> => await ipcRenderer.invoke("smule.groups.join", groupId),
        /**
         * Uploads a cover picture for a group
         * @param imageData The image data
         * @returns The resource ID of the uploaded image, to be used in `create`
         */
        uploadCoverPicture: async (imageData: Uint8Array): Promise<any> => await ipcRenderer.invoke("smule.groups.uploadCoverPicture", imageData),
        /**
         * Creates a group
         * @param name The name of the group
         * @param desc The description of the group
         * @param lang The language
         * @param loc The location (XX - global)
         * @param picId The resource id of the cover picture
         * @param sfamTag The global group tag
         * @returns The group
         */
        create: async (name: string, desc: string, lang: string, loc: string, picId: number, sfamTag: string): Promise<import("../../node_modules/smule.js/dist/index").SFam> => await ipcRenderer.invoke("smule.groups.create", name, desc, lang, loc, picId, sfamTag),
        /**
         * Posts multiple performances to a group's feed
         * @param performanceKeys The performances to post
         * @param groupId The ID of the group
         */
        postPerformances: async (performanceKeys: string[], groupId: number): Promise<void> => await ipcRenderer.invoke("smule.groups.postPerformances", performanceKeys, groupId),
        /**
         * Removes a post from a group
         * @param groupId The ID of the group
         * @param postId The ID of the post
         * @param postType The type of the post
         */
        removePost: async (groupId: number, postId: number, postType?: "FEED"): Promise<void> => await ipcRenderer.invoke("smule.groups.removePost", groupId, postId, postType),
    },
  
  playlists: {
        
        create: async (name: string, visibility?: import("../../node_modules/smule.js/dist/index").PlaylistVisibility): Promise<import("../../node_modules/smule.js/dist/index").PlaylistIcon> => await ipcRenderer.invoke("smule.playlists.create", name, visibility),
        
        addPerformance: async (playlistKey: string, performanceKey: string): Promise<void> => await ipcRenderer.invoke("smule.playlists.addPerformance", playlistKey, performanceKey),
        
        changeVisibility: async (playlistKey: string, visibility: import("../../node_modules/smule.js/dist/index").PlaylistVisibility): Promise<import("../../node_modules/smule.js/dist/index").PlaylistIcon> => await ipcRenderer.invoke("smule.playlists.changeVisibility", playlistKey, visibility),
        
        changeName: async (playlistKey: string, name: string): Promise<import("../../node_modules/smule.js/dist/index").PlaylistIcon> => await ipcRenderer.invoke("smule.playlists.changeName", playlistKey, name),
        
        fetchOne: async (playlistKey: string, sortMethod: import("../../node_modules/smule.js/dist/index").PlaylistSortMethod, cursor?: string, limit?: number): Promise<import("../../node_modules/smule.js/dist/index").PlaylistViewResult> => await ipcRenderer.invoke("smule.playlists.fetchOne", playlistKey, sortMethod, cursor, limit),
        
        deleteOne: async (playlistKey: string): Promise<void> => await ipcRenderer.invoke("smule.playlists.deleteOne", playlistKey),
    },
  
  TEST: {
        
        runRawRequest: async (url: string, data: any): Promise<import("../../node_modules/smule.js/node_modules/axios/index").AxiosResponse<any, any>> => await ipcRenderer.invoke("smule.TEST.runRawRequest", url, data),
    },
}
export const smuleDotCom = {
    /**
     * Clears the saved cookies
     */
    resetCookies: async (): Promise<void> => await ipcRenderer.invoke("smuledotcom.resetCookies"),
    /**
     * Fetches the locally saved user data
     * @returns The user data
     */
    getAccount: async (): Promise<import("../../node_modules/smule.js/dist/index").SDCUser> => await ipcRenderer.invoke("smuledotcom.getAccount"),
    /**
     * Fetches a new CSRF token, required for certain actions
     */
    fetchXsrfToken: async (): Promise<Promise<void>> => await ipcRenderer.invoke("smuledotcom.fetchXsrfToken"),
    /**
     * Checks whether an account with given email
     * address exists
     */
    checkEmailExists: async (email: string): Promise<Promise<any>> => await ipcRenderer.invoke("smuledotcom.checkEmailExists", email),
    /**
     * Logs into an account
     * @returns whether the action was successful
     */
    login: async (email: string, password: string): Promise<Promise<boolean>> => await ipcRenderer.invoke("smuledotcom.login", email, password),
    /**
     * Fetches the currently logged in user
     * @returns Either the user, or null
     */
    fetchAccount: async (): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCUser>> => await ipcRenderer.invoke("smuledotcom.fetchAccount"),
    /**
     * Creates a new arrangement
     * @param songFile The mp3 file you wish to upload
     * @returns An empty arrangement
     */
    createArrangement: async (songFile: Uint8Array): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCArr>> => await ipcRenderer.invoke("smuledotcom.createArrangement", songFile),
    /**
     * Fetches the upload data for an already published arrangement
     * @param arrKey The arrangement's key
     * @returns The arrangement's song config
     */
    fetchArrUploadData: async (arrKey: string): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCArrSongConfig>> => await ipcRenderer.invoke("smuledotcom.fetchArrUploadData", arrKey),
    /**
     * Autogenerate segments for your lyrics
     * @param arr Your arrangement
     * @returns The generated segments
     */
    generateSegments: async (arr: import("../../node_modules/smule.js/dist/index").SDCArr): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCGeneratedSegmentsResponse>> => await ipcRenderer.invoke("smuledotcom.generateSegments", arr),
    /**
     * Save an arrangement
     * @param arr The arrangement to save
     * @returns Data about the arrangement (ex: the web url)
     */
    saveArr: async (arr: import("../../node_modules/smule.js/dist/index").SDCArr): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCSaveArrResponse>> => await ipcRenderer.invoke("smuledotcom.saveArr", arr),
    /**
     * Fetches title suggestions
     */
    fetchTitleAutocomplete: async (query: string): Promise<Promise<{ title: string; }[]>> => await ipcRenderer.invoke("smuledotcom.fetchTitleAutocomplete", query),
    /**
     * Fetches artist suggestions
     */
    fetchArtistAutocomplete: async (query: string): Promise<Promise<{ value: string; }[]>> => await ipcRenderer.invoke("smuledotcom.fetchArtistAutocomplete", query),
    /**
     * Fetches genre suggestions
     * @remarks You can only upload genres that are autocompleted
     */
    fetchGenreAutocomplete: async (query: string): Promise<Promise<{ value: { topicId: number; name: string; }; }[]>> => await ipcRenderer.invoke("smuledotcom.fetchGenreAutocomplete", query),
    /**
     * Fetches tag suggestions
     */
    fetchTagAutocomplete: async (query: string): Promise<Promise<{ value: string; }[]>> => await ipcRenderer.invoke("smuledotcom.fetchTagAutocomplete", query),
    /**
     * Verifies if a song already exists with the same details (i think)
     * @param title Your arrangement's title
     * @param artist Your arrangement's artist
     * @param tags Your arrangement's tags
     * @returns Whether or not you're restricted (i think)
     */
    matchCatalog: async (title: string, artist: string, tags: string[]): Promise<Promise<{ restricted: boolean; cover?: any; }>> => await ipcRenderer.invoke("smuledotcom.matchCatalog", title, artist, tags),
    /**
     * Detects the language of the text provided (usually lyrics)
     * @param text The text to detect
     * @returns The detected language
     */
    detectLanguage: async (text: string): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCDetectLanguageResponse>> => await ipcRenderer.invoke("smuledotcom.detectLanguage", text),
    /**
     * Delete an arrangement
     * @param arrKey The arrangement's key
     */
    deleteArr: async (arrKey: string): Promise<Promise<import("../../node_modules/smule.js/dist/index").ApiResult<{}>>> => await ipcRenderer.invoke("smuledotcom.deleteArr", arrKey),
    /**
     * Fetches a user's profile
     * @param username The user's username
     * @returns The user's profile
     */
    fetchProfile: async (username: string): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCProfileResult>> => await ipcRenderer.invoke("smuledotcom.fetchProfile", username),
    /**
     * Fetches the songs of a user
     * @param accountId The user's account id
     * @param offset Start index
     * @param limit How many
     * @returns The user's songs
     */
    fetchSongs: async (accountId: string | number, offset?: number, limit?: number): Promise<Promise<import("../../node_modules/smule.js/dist/index").SDCProfileSongsResult>> => await ipcRenderer.invoke("smuledotcom.fetchSongs", accountId, offset, limit),
}