// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣀⢸⣿⣿⣀⣤⡀⢠⣄⡄⢀⣄⣀⣀⣿⣿⣄⠀⠀⠀⢠⣀⡄⢠⣀⡄⢠⣀⣀⣠⣄⠀⠀⠀⠀⢸⣿⣿⣠⣄⡀⠀⣄⣠⣀⡄⠀⣠⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣿⣿⣛⠋⢸⣿⣿⢿⣿⣷⢸⣿⡏⢸⣿⣯⠻⣿⣿⠿⠀⠀⠀⣸⣿⡇⢸⣿⡇⢸⣿⡿⢻⣿⣷⠀⠀⠀⢸⣿⣿⠻⣿⣷⠀⣿⣿⡿⠇⣾⣿⠟⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣉⢻⣿⣷⢸⣿⡷⢸⣿⣟⢸⣿⣷⣸⣿⡟⠀⣿⣿⠀⠀⠀⠀⢺⣿⣇⣸⣿⡇⢸⣿⣧⣸⣿⣿⠀⠀⠀⢸⣿⣿⣀⣿⣿⠀⣿⣿⠀⠐⣿⣿⣀⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢻⣿⣿⠋⢸⣿⡟⠘⣿⡟⠀⢻⣿⣿⡟⠃⠀⣿⣿⠃⠀⠀⠀⠈⢻⣿⣿⡟⠁⢸⣿⡟⣿⣿⠃⠀⠀⠀⢸⣿⡟⢻⣿⠋⠀⣿⣿⠀⠀⠙⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢀⡀⢂⡠⠟⠉⠸⢏⠽⣩⣯⢟⣫⣍⠉⠉⠉⠉⣡⣄⣉⣭⠟⠉⠁⠀⠀⣠⡩⠷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠓⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⢇⠉⡈⠁⠉⣉⡟⠁⠀⣼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀
// ⢀⠴⢋⣰⡋⡴⣒⠲⣄⣯⣿⢟⣥⣟⡳⣎⣵⠀⠀⢸⡝⣾⣿⠃⡀⣀⡀⠠⣾⠋⠀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠸⡄⠠⠁⢠⡟⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠐⠊⠁⠀
// ⠁⠐⣹⡿⣽⢳⢧⢷⣼⢳⢼⡹⢶⣭⢳⣽⡞⠀⠀⣾⣹⡿⢁⣼⠋⠀⠘⡎⠉⢆⠀⢀⡰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⢄⡀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⢣⠀⠐⡾⠁⠀⠀⢸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠒⠉⠀⠀⠀⠀⠀⠀
// ⠀⣰⢿⣯⡳⣏⢾⡈⣷⢫⠶⣙⠷⣎⡿⠋⠀⠀⣴⣹⡟⣰⢟⠁⠀⠀⢀⡼⠁⠉⠱⠋⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠢⢄⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠈⢧⣸⠃⠀⠀⠀⣞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⢀⠇⠀⠙⢷⣛⢮⠷⣌⢟⡺⣍⣾⠩⡐⠀⣆⣻⣯⠋⠔⠁⣈⡵⢄⡠⠛⡄⠀⠀⡀⠀⠀⠀⣠⣶⢿⣿⣳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠸⡇⠀⠀⠀⢰⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠁⠀⠀⠀⠀⠻⣏⡿⣜⠯⣝⡳⣷⢂⠱⠆⣀⡽⢁⠔⢂⠖⣻⡀⠀⢁⡴⠁⡠⠞⠁⠀⣠⣾⣟⢾⣻⣼⣳⢯⡿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⣸⠀⠀⠀⠀⣾⣿⡇⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠎⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠈⠳⣯⣻⢼⣱⢼⡛⣿⣾⠏⠀⢁⠴⢁⠞⡡⠓⣤⠎⣠⠊⠄⢀⣤⣾⣟⡷⣯⣻⢧⣟⡾⢯⡽⣯⣟⣷⣄⡀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠈⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⡇⠀⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢀⠀⠠⠐⡈⠔⠈⠳⣯⣾⡷⠟⠋⠁⠉⣿⣯⠀⡡⠊⣠⠞⣡⣞⠻⣤⣴⣿⣿⣿⣿⣽⣳⢯⣟⡾⣽⢯⡿⣵⣻⣾⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠀⠀⡇⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠸⠁⠀⠀⢀⣿⣿⣿⣿⣯⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⢀⡐⠠⢈⢂⠡⠰⢄⡠⠔⢋⡁⠀⠀⠀⠀⠀⣿⢿⣿⡄⠚⣡⠟⢁⠈⢳⡍⠹⣿⣟⣿⣳⢷⣫⣟⡾⣽⣛⡾⣽⣳⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⣰⡇⠀⢀⠀⠀⠀⠈⠉⣩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣀⠄⡁⠂⡄⠂⢡⠎⠀⠀⠀⠙⠢⡀⠀⠀⢠⣿⣯⣯⣧⠞⠁⡈⠄⠊⠄⡈⠱⢠⠙⢷⣯⣟⣳⢯⣽⣳⢯⣿⣿⣿⠟⢿⠛⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⡴⠋⣿⣦⡜⠀⠀⠀⢠⠊⠀⠀⠙⠻⢿⡿⣿⡟⠁⠈⠉⠀⢀⣀⣠⣴⣾⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠻⢿⣶⣅⡠⢠⢎⣀⣤⣶⣶⣶⣦⣜⣦⡀⠘⠿⣻⣟⡇⣀⣠⣀⣈⡐⠈⠄⣁⠂⡉⠤⡙⢿⣽⣻⢾⣽⣿⣿⣿⠟⠀⠈⠀⠈⠻⣿⣦⡀⠀⠀⠀⠀⢠⠞⠀⠀⡈⠿⠑⠤⡀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠽⣦⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⠻⡄⠀⠀⠀⠀⠀⠀⠀⠀⡸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠦⡘⣍⠻⣧⣾⣾⣿⢿⣟⣿⣿⣿⣿⣿⣷⣤⠤⠟⠛⠷⣟⠋⠛⠛⠓⢦⣐⠉⠤⠁⡄⠱⣈⠻⣿⡾⠿⠛⠋⠉⠀⠀⠀⠀⠀⠀⠙⢿⣧⡀⠀⣀⠀⡞⠀⢀⠔⠁⠀⠀⠀⡇⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⠀⢣⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣶⣵⣨⡑⣿⣿⣷⣿⣿⡿⣟⣿⢾⣷⣯⣟⣿⣷⡀⠀⠀⠀⠙⢦⡀⠀⠀⠘⣧⡀⠃⠄⣡⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⡃⠸⣏⠙⠳⣄⠊⠀⠀⠀⢀⠜⠁⠀⢀⣷⣄⡀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⠅⠀⣀⠤⠑⠢⣀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⢢⢍⢛⠻⢾⣟⣿⣿⡷⣿⣟⣯⣿⣾⢯⣿⣟⣿⣧⠀⠀⠀⠀⠀⢷⠀⠀⠀⡏⠙⣆⡼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠔⠋⠳⢄⡈⠳⣄⠀⠠⠊⠀⠀⠀⠀⠛⠿⣿⣷⣶⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠉⢿⢯⠉⠀⣠⠞⠁⠀⠀⠀⠀⠉⠒⢄⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⡒⢬⢊⡕⠣⣍⠻⢿⣿⣿⣽⣟⣷⣿⣻⣷⣿⣯⣿⡧⠴⠒⠋⠉⠉⠉⠉⠉⠙⠙⢻⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⢀⣆⠀⠀⠈⠙⢻⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠹⣏⠁⠀⠀⠀⠀⠀⠀⠀⠀⢐⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠔
// ⡝⣶⢣⡼⣱⢎⡷⣣⢾⣿⣿⣿⣿⣻⣿⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢾⡒⠺⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠎⠘⡆⠀⠀⠀⠀⢿⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠖⠋⠀⠀⠀⠘⣆⠀⠀⠀⠀⠀⠀⣀⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠔⠁⠀⠀
// ⣻⣼⣿⣽⣯⣿⣽⣿⣯⣟⣿⣿⣏⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣀⣻⣤⣄⡤⠤⠤⠤⠖⠒⡏⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠸⡄⠀⠀⢀⣴⣿⣿⣷⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠊⠁⠀⠀⠀⠀
// ⠻⣿⣟⣯⡟⣿⢻⣻⢟⣿⣻⣟⡿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣇⠀⠀⠀⠀⢸⡄⠁⠀⢳⡀⠀⠀⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠀⠀⢷⢀⣴⣿⣿⡟⡿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠋⣑⡷⠂⠀⠀⠀⠀
// ⠀⠈⠙⠿⣿⣽⣻⣜⣋⠍⡉⣘⣛⣓⣛⣽⡷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠯⠤⢤⡤⠀⣼⠴⠒⠋⡙⠳⣄⠀⠀⠀⠀⢸⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⢸⣿⣿⢟⣱⡙⣾⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠉⠀⠀⠀⠀⠀⠀⠀
// ⠀⠡⠈⡀⠉⠻⣷⣯⣟⡷⣔⠠⠄⢋⠫⠿⡽⣿⣻⣦⡀⠀⠀⠀⣀⣤⠴⠖⠾⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣠⠴⠊⠁⠀⠀⢾⠁⣼⣃⣤⢥⡦⡐⢄⠉⠓⢦⡀⠀⡞⠀⠘⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⡸⠁⠀⠀⢸⡿⡱⣎⢧⣹⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠉⠑⠢⣄⠀⠀⠀⠀⠀⠀
// ⠀⠡⠐⠀⡁⠄⠈⢻⣿⣽⣻⣷⠈⠄⠂⠌⡉⠟⢛⣛⣷⣆⡀⠀⠻⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⢞⠋⡉⠉⢧⠻⣇⢀⠀⠀⠀⠀⠈⢻⡉⠀⠀⢾⣥⠌⢂⡜⡈⡌⣻⣴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⢸⡗⡻⣜⢲⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠑⠢⢄⠀⠀⠀
// ⢦⡁⢈⠐⡀⠌⡐⢀⠘⢻⣷⡽⣷⡈⡐⠄⡐⠠⢈⠙⢯⠿⢿⣦⣄⡔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⡡⠊⠐⠀⠀⣾⢁⡛⢏⠳⣆⠀⠀⢀⣰⣧⢶⠀⠀⠈⠻⣏⠰⢠⡽⠁⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⣸⣗⠳⣜⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠋⠀⢀⡴⣻⣟⠲⣄⣀⠀⠀⠉⠢⡄
// ⣃⡙⠢⠔⡀⢂⠐⡀⠂⠈⠹⣿⣽⣻⣧⣐⡀⢁⠂⠌⠠⠙⠯⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠄⠁⠠⠁⠀⢰⡏⠢⢜⣠⠿⣙⣷⣾⣿⠟⢡⡟⠀⠀⠀⠀⢙⣧⡟⠀⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⠀⡰⠃⣯⣻⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⢀⡴⣫⣾⢿⣿⣿⣾⣿⣿⣶⣄⠀⠀
// ⡥⣉⠓⡒⠄⠦⣄⠠⠁⠌⡀⠛⣿⣷⡽⣻⢷⣦⡈⠄⡁⢂⠌⢉⠛⡻⠷⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠈⠐⠈⠀⠀⢠⣿⠵⡛⣋⠑⡢⢻⡿⢿⡁⠀⠀⠉⠙⠲⣄⡀⠛⣟⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⣀⡠⠔⠋⠀⠀⡟⠁⠀⠀⢀⣀⠤⠒⠒⠂⠉⠉⠑⠒⠦⣼⠁⢀⡴⢫⢾⣟⣼⣳⣾⣿⣿⣿⣿⣿⣿⣿⡶
// ⣳⣭⣛⡴⣋⢮⣕⣒⡥⢆⡐⠠⢘⣿⣿⣿⣾⡵⣿⣦⡐⠂⠌⡀⠆⠡⢋⡙⢣⢻⣟⣶⣄⠀⠀⠀⠀⠀⠀⣿⠀⠠⠀⠀⠀⣼⢃⠎⡱⢠⢋⣴⠗⢣⢊⣧⠀⠀⣤⠖⠋⠉⠀⠀⠘⣶⣤⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠋⠁⠀⠀⠀⠀⢠⣁⡠⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣯⣾⣿⣦⣈⣿⣿⣿⣿⣿⣿⣿⣿⡿⣫⣾
// ⣿⣾⣽⣷⣟⣾⣼⣭⣛⢧⣺⡱⢎⠾⣽⣿⣿⣿⡷⣯⢿⣷⣶⣶⣾⣶⣷⣿⣷⣿⣾⣷⣻⣧⡀⠀⠀⠀⠀⡯⠀⠀⠀⠀⢼⣏⣢⣼⠴⣛⠫⠤⡙⠤⣣⣿⠀⠀⠈⢷⠀⠀⢀⣀⣠⠼⢛⠅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⣀⠴⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢫⣾⣿⣿
// ⣿⡿⣿⠿⣿⢿⡿⣿⣿⣿⣧⣿⣟⣿⣤⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⣇⠀⠀⠀⢀⡿⢛⠃⡄⠇⡄⢇⢣⢸⡼⢇⣻⠀⠀⢀⡿⠀⠀⠘⣧⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⣀⠼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⣼⣿⣿⣿⣿
// ⡳⣝⢮⡻⣜⣣⡝⣖⣣⠯⣝⡻⣟⠿⡻⢿⢿⣿⣿⣿⣿⣿⢯⣭⣖⢒⣂⣤⡀⠄⡈⢉⠉⠛⠻⢿⣿⣷⣦⣽⡆⠈⠀⣼⠣⢌⡒⣌⣶⣼⣦⣟⢋⠜⣂⣾⠀⠀⠛⠁⠀⣀⣠⠿⠐⠒⠚⠒⠒⠤⢄⡀⠀⠀⠀⠀⠀⢀⡏⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⠟⣵⣾⣿⣿⣿⣿⣿
// ⡟⣼⢣⡟⣼⢣⡟⣴⢣⢟⡲⡝⣼⡹⣅⠛⡘⠶⣭⢻⠿⣿⣿⣿⣾⢿⣶⣚⠀⠆⡁⢂⠌⠌⡁⢂⢲⣭⠿⣿⣿⡄⠀⣿⣾⣾⣿⣿⣿⣿⣿⣿⣿⣮⢦⡏⠀⣀⠤⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠓⢤⡀⠀⠀⡼⢳⣞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠃⢀⣿⣿⣿⣿⣿⣿⡟⣣⣿⣿⣿⣿⣿⣿⣿⣿
// ⡿⣜⣧⢻⡜⣧⢻⣜⡹⣮⢳⣝⠶⣩⣛⢷⣄⠒⡈⠳⠉⠖⣹⠻⣿⣿⣾⣻⢿⣦⡠⠁⠌⡐⠠⢁⠂⠸⠻⠽⣯⣿⣦⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡗⠉⠀⠀⠀⠀⡖⠒⠦⠴⠤⠤⣄⣀⠀⠀⠀⠀⠀⠘⠆⢰⠃⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⣼⣿⣿⣿⣿⣿⠷⠾⠿⢿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣱⡞⣯⣝⣞⡳⣎⠷⣭⡿⣌⡛⠳⣮⡳⣝⢷⣄⡁⢊⠐⡈⠑⡈⠿⣿⣿⣯⣟⣿⣮⡐⠠⣁⠂⠌⣡⠙⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠸⡏⠙⠛⠒⠤⠤⣀⡀⠀⠈⠙⠲⣄⡀⠀⠀⠀⡞⠀⠀⢾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠃⠀⠀⢰⣿⠿⠛⠋⠉⠀⠀⠀⠀⠀⢼⣿⣿⣿⣿⣿⣿
// ⣷⢣⣟⠾⣜⡾⣹⡭⣟⢶⡹⣯⣳⢧⡀⠛⢾⣎⡽⣳⣤⠁⠄⢃⠐⡠⠈⠿⣿⣿⣾⣽⣻⣧⡀⠌⠤⡙⣿⡿⣽⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠉⠑⢢⡄⠀⠈⢷⣄⠀⣰⠃⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⢰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿
// ⣯⢻⡼⣻⡝⡾⣵⢻⡼⣫⢷⡹⡽⣧⡟⢦⡈⠙⣶⡝⣞⠿⣔⢈⠐⡠⢁⠂⠜⣻⣿⣷⣯⣟⣿⣎⠔⡡⠜⣿⣷⣻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⢀⠴⠉⣿⠀⠀⠘⣏⢶⡃⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠉⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿
// ⣯⠷⡽⢧⡟⣵⣏⢷⣫⢗⡯⣽⢳⣝⠾⣧⣝⢤⠀⠛⢯⡞⡽⣷⡄⠐⠄⠊⠄⡉⠻⣿⣿⣿⣞⡿⣷⣡⢋⠴⣻⣯⣟⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⢀⠴⠊⠀⠀⢸⡄⠂⠈⣷⠈⣷⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠴⠊⠁⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣰⣿⣿⣿⣿⣿⣿
import * as yauzl from "yauzl"

export namespace SmuleEffects {
    export type AVFile = {
        component_library: ComponentLibrary,
        template: Template,
        copyright: string,
        files: {[key: string]: {}|string}
    }
    export type ComponentLibrary = {
        components: Component[],
        copyright: string,
        fallback_component_id: number
    }
    export type Component = {
        component_id: string;
        duration: number;
        file_path: string;
        input_count: number;
        name: string;
        parameters: ComponentParameter[];
        preview_file_path: string;
        tags: string[];
        type: "Audio Effect"|string; // TODO: find the other types
    }
    export type ComponentParameter = {
        default_value: number,
        expose_to_joiner: boolean,
        expose_to_singer: boolean,
        max_value: number,
        min_value: number,
        name: string,
        targets: string[],
        type: "Number"|string // TODO: find the other types
    }

    export type Template = {
        copyright: string,
        default_parameter_value: number[],
        description: string,
        inverse_background_color: number[],
        min_renderer_generation: number,
        name: string,
        parameters: TemplateParameter[],
        segments: TemplateSegment[],
        tags: string[],
        type: "standard"|string //TODO: find the other types
    } 
    export type TemplateParameter = {
        data_type: "Float"|string, //TODO: find the other types
        default_value: number,
        expose_to_joiner: boolean,
        max_value: number,
        min_value: number,
        name: string
    }
    export type TemplateSegment = {
        afx?: TemplateAFX[],
        always_show_all_participants: boolean,
        apply_global_effects_first: boolean,
        max_performer_count: number,
        override_global_video_effects: boolean,
        type: "Global"|"Intro"|"Verse"|"Pre-Chorus"|"Chorus"|"Bridge"|"Outro"|string // TODO: discover whether theres others too or not
    }
    export type TemplateAFX = {
        metadata_id: string,
        metadata_name: string,
        expressions: {
            [key: string]: AFXExpression
        }
    }
    export type AFXExpression = {
        modifier_end_value: number[],
        modifier_start_value: number[],
        modifiers: any[],
        numeric_value: number[]
    }
    export type AFXExpressionModifier = {
        curve: AFXExpressionModifierCurve,
        end_value: number,
        source: "Template Parameter"|string,
        source_parameter_name: string,
        start_value: number
    }
    export type AFXExpressionModifierCurve = {
        key_frames: number[][],
        key_frames_offset_x: number
    }
    export type AlygFile = {
        layout: {
            [key: string]: number[]
        },
        filters: AlygFilter[],
        ui_graph_view_width?: number,
        input_count: number,
        description: string,
        ui_window_frame?: number[],
        parameters: AlygParameter[]
    }
    export type AlygParameter = {
        initial_value: number,
        name: string
    }
    export type AlygFilter = {
        shader_type: "filter_graph",
        inputs: string[],
        name: string,
        expressions: string[], // these are runnable stuff or sth
        shader_settings: {
            file_path?: string,
            scale_mode?: "fill_aspect_ratio" | string,
            blend_mode?: "normal" | string
        }
    }
    
    export function processZipFile(filePath: string): Promise<AVFile> {
        return new Promise((resolve, reject) => {
            yauzl.open(filePath, {lazyEntries: true, decodeStrings: false}, (err, zipfile) => {
                let filesRead = 0
                if (err) throw err
                zipfile.readEntry()

                let data: AVFile = {
                    component_library: {} as ComponentLibrary,
                    template: {} as Template,
                    copyright: "my ass",
                    files: {}
                }
                zipfile.on("entry", (entry: yauzl.Entry) => {
                    let fileName = (entry.fileName as unknown as Buffer).toString("utf-8")

                    if (fileName.endsWith(".alyc")) {
                        if (Object.keys(data.component_library).length > 1) {
                            console.warn("[SmuleEffects] Double component_library file? that shouldnt happen i think? Overwriting...")
                        }
                        zipfile.openReadStream(entry, (err, stream) => {
                            if (err) throw err
                            let rawData = []
                            stream.on("data", (chunk) => {
                                rawData.push(chunk)
                            })
                            stream.on("end", () => {
                                let componentLibrary = JSON.parse(Buffer.concat(rawData).toString("utf-8"))
                                data.component_library = componentLibrary
                                filesRead++
                            })
                        })
                    } else if (fileName.endsWith(".alyt")) {
                        if (Object.keys(data.template).length > 1) {
                            console.warn("[SmuleEffects] Double template file? that shouldnt happen i think? Overwriting...")
                        }
                        zipfile.openReadStream(entry, (err, stream) => {
                            if (err) throw err
                            let rawData = []
                            stream.on("data", (chunk) => {
                                rawData.push(chunk)
                            })
                            stream.on("end", () => {
                                let template = JSON.parse(Buffer.concat(rawData).toString("utf-8"))
                                data.template = template
                                filesRead++
                            })
                        })
                    } else if (fileName.endsWith(".alyg") || fileName.endsWith(".json")) {
                        zipfile.openReadStream(entry, (err, stream) => {
                            if (err) throw err
                            let rawData = []
                            stream.on("data", (chunk) => {
                                rawData.push(chunk)
                            })
                            stream.on("end", () => {
                                data.files[fileName] = JSON.parse(Buffer.concat(rawData).toString("utf-8"))
                                filesRead++
                            })
                        })
                    } else if (fileName == "copyright.txt") {
                        zipfile.openReadStream(entry, (err, stream) => {
                            if (err) throw err
                            let rawData = []
                            stream.on("data", (chunk) => {
                                rawData.push(chunk)
                            })
                            stream.on("end", () => {
                                data.copyright = Buffer.concat(rawData).toString("utf-8")
                                filesRead++
                            })
                        })
                    } else if (fileName.endsWith(".txt")) {
                        zipfile.openReadStream(entry, (err, stream) => {
                            if (err) throw err
                            let rawData = []
                            stream.on("data", (chunk) => {
                                rawData.push(chunk)
                            })
                            stream.on("end", () => {
                                data.files[fileName] = Buffer.concat(rawData).toString("utf-8")
                                filesRead++
                            })
                        })
                    } else {
                        // TODO: maybe load the raw buffer into ram to be used later on?
                        data.files[fileName] = fileName
                        filesRead++
                    }

                    zipfile.readEntry()
                })
                zipfile.on("end", () => {
                    let entries = zipfile.entriesRead
                    zipfile.close()
                    // wait for all the files to finish loading
                    let interval = setInterval(() => {
                        if (entries > filesRead) return
                        clearInterval(interval)
                        resolve(data)
                    }, 1)
                })
            })
        })
    }

    export function processRawEffects(data: AVFile) {

    }
}