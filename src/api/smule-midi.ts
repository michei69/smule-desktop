// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠛⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠉⠀⣠⣶⣶⣄⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⣀⣶⣿⣿⣿⣿⣿⣆⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠁
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠁⢀⣤⣶
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠁⢀⣠⣾⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠋⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠈⠉⠉⠙⠛⠛⠻⢿⣿⡿⠟⠁⠀⣀⣴⣿⣿⣿⣿⣿⠟
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⣉⣡⠀⣠⣴⣶⣶⣦⠄⣀⡀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⡿⢃⣾
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⣾⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣠⣾⡟⢡⣾⣿⣿⣿⡿⢋⣴⣿⡿⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⢡⣾⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠃⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⣼⣿⡟⣰⣿⣿⣿⣿⠏⣰⣿⣿⠟⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢚⣛⢿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⠸⣿⠟⢰⣿⣿⣿⣿⠃⣾⣿⣿⠏⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⣾
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠻⠻⠃⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⢉⣴⣿⣿⣿⣿⡇⠘⣿⣿⠋⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡘⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⣿⣿⣿⣿⠁⢀⣀⠀⢀⣾⣿⣿⣿⣿⣿⣿⠟⠉⠉⠉⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣤⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣌
// ⣿⣿⣿⣿⣿⣿⡿⠁⣀⣤⡀⠀⠈⠻⢿⠀⣼⣿⣷⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⠟⠛⠙⠃⠀⣿⣿⣿⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⡿⠿⠿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠁⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿
// ⣿⠟⠁⢀⣴⣶⣶⣾⣿⣿⣿⣿⣶⡐⢦⣄⠀⠀⠈⠛⢿⣿⣿⣿⣿⡀⠀⠀⠀⠀⢀⣼⡿⢛⣩⣴⣶⣶⣶⣶⣶⣶⣭⣙⠻⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿
// ⠁⠀⣴⣿⣿⣿⣿⠿⠿⣿⣿⣿⣿⣿⣦⡙⠻⣶⣄⡀⠀⠈⠙⢿⣿⣷⣦⣤⣤⣴⣿⡏⣠⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣌⠻⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⣿⠋⣠⠔⠀⠀⠻⣿⣿⣿⣿⢉⡳⢦⣉⠛⢷⣤⣀⠀⠈⠙⠿⣿⣿⣿⣿⢸⣿⡄⠻⣿⣿⠟⡈⣿⣿⣿⣿⣿⢉⣿⣧⢹⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⡇⠠⡇⠀⠀⠀⠀⣿⣿⣿⣿⢸⣿⣷⣤⣙⠢⢌⡛⠷⣤⣄⠀⠈⠙⠿⣿⣿⣿⣿⣷⣦⣴⣾⣿⣤⣙⣛⣛⣥⣾⣿⣿⡌⣿⣿⣿⣷⣤⣀⣀⣀⣠⣴⣿⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⣷⡀⠡⠀⠀⠀⣰⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣦⣌⡓⠤⣙⣿⣦⡄⠀⠈⠙⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢡⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⣿⣿⣶⣤⣴⣾⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣷⣾⣿⣿⣷⠀⣶⡄⠀⠈⠙⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢃⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⣿⣿⣿⠟⠻⣿⣿⡏⣉⣭⣭⡘⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣿⡇⢸⡇⢠⡀⠈⠙⠋⠉⠉⠉⠉⠛⠫⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⠛⣿⣿⣀⣀⣾⡿⢀⣿⣿⣿⢻⣷⣦⢈⡙⠻⢿⣿⣿⣿⣿⣿⣿⣿⠀⣿⡇⢸⡇⢸⣿⠀⣦⠀⠀⠶⣶⣦⣀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⢸⣿⣿⣦⣈⡛⠿⠟⣋⣤⣾⣿⣿⣿⣸⣿⣿⢸⡇⢰⡆⢈⡙⠻⢿⣿⣿⣿⠀⢿⡇⢸⡇⢸⣿⢠⣿⡇⣿⡆⢈⡙⠻⠧⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⠀⣝⠛⢿⣿⣿⣿⣿⣿⣿⠟⣁⠀⠀⢈⠛⠿⢸⣇⢸⡇⢸⡇⣶⣦⣌⡙⠻⢄⡀⠁⠘⠇⠘⣿⢸⣿⡇⣿⡇⢸⡛⠷⣦⣄⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⡆⠀⠈⠳⢶⣤⣍⡉⠉⣩⣤⣤⡉⠻⢶⣤⣀⠂⠀⠉⠘⠇⢸⡇⣿⣿⣿⣿⣷⣦⣍⡑⠢⣄⠀⠈⠈⠻⠇⣿⡇⢸⣿⣷⣾⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣷⣦⣄⡀⠈⠉⠛⠶⢄⡉⠻⠿⣷⣦⣌⡙⠷⢶⣄⡀⠀⠈⠁⠙⢿⣿⣿⣿⣿⣿⣿⣷⣦⣍⡒⠤⣀⠀⠈⠃⢸⣿⣿⣿⣿⣷⠀⢸⣿⣿⣿⣿⣿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⠿
// ⣿⣿⣿⣿⣿⣷⣦⣄⡀⠀⠈⠉⠂⠄⢙⣿⣿⣷⣦⣈⠙⠳⢦⣄⡀⠠⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣌⡐⠄⢸⣿⣿⣿⣿⣿⡇⠀⣿⠿⣿⣿⣿⣿⣷⣌⠻⣿⣿⣿⡿⢰⣦⣤
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣄⡀⠀⠀⠀⠉⠛⠛⠛⠿⠷⣤⣈⠛⠷⢤⣈⡂⢄⡉⠻⠿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣌⡛⠿⣿⣿⡇⠀⢿⣷⣌⡛⠿⠿⠏⣼⣷⣤⣉⣉⣀⣼⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡷⠀⢀⣤⣶⣦⣤⣤⣄⡈⠙⠻⠖⠀⣉⣩⣤⣤⣤⣤⣤⣤⣀⡈⠉⠙⠻⣿⣿⣿⣿⣶⡄⠉⠀⠀⣸⣿⣿⣿⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⣾⣿⣿⣿⣿⣿⣿⣿⠀⠀⣴⣿⣿⣿⣿⣿⠟⣩⣽⣿⣿⣿⣷⣦⣀⠀⠙⢻⣿⣿⠇⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⠏⣵⣾⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⡀⠉⠻⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⡇⠘⣿⣿⡿⣡⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⣦⡀⠀⠸⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢀⣀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⢀⣙⣟⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣘⣛⣻⣦⢀⣀⣙⣛⣛⣛⣛⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
import * as midiParser from "midi-file";

//TODO: finish this lol
export namespace SmuleMIDI {
    export enum SmuleUserSinging {
        BOTH,
        PART_ONE,
        PART_TWO,

        // TODO: implement eventually
        PART_THREE,
        PART_FOUR,
        PART_FIVE,
        PART_SIX,
        PART_SEVEN,
        PART_EIGHT
    }

    export type SmuleSyllable = {
        text: string,
        startTime: number,
        endTime: number
    }
    export type SmuleLyric = {
        text: Array<SmuleSyllable>,
        startTime: number,
        endTime: number,
        part: SmuleUserSinging
    }
    export type SmuleMidiData = {
        lyrics: Array<SmuleLyric>,
        pitches: SmulePitchesData,
        isSyllable: boolean,
        type: "RAVEN" | "COMMUNITY"
    }
    export type SmuleLyricsData = {
        lyrics: Array<SmuleLyric>,
        isSyllable: boolean
    }

    export type SmulePitch = {
        noteNumber: number,
        startTime: number,
        endTime: number,
        part: SmuleUserSinging | number
    }
    export type SmulePitchesData = {
        pitches: SmulePitch[],
        largestNote: number,
        smallestNote: number
    }
    type rawSmuleSections = {
        [key: string] : {
            on: Array<number>,
            off: Array<number>
        },
    }
    type rawSmuleSectionsData = {
        sections: rawSmuleSections,
        type: "RAVEN" | "COMMUNITY"
    }
    function cleanLyric(lyric: string, isSyllable = false) {
        lyric = Buffer.from(lyric, "ascii").toString("utf-8")
        if (isSyllable) return lyric

        return lyric.replaceAll("\\n", "") // remove newlines
                    .trim()
    }

    function processSections(sectionsTrack: midiParser.MidiEvent[], multiplier: number): rawSmuleSectionsData {
        let rawSections = {}
        let type: "RAVEN" | "COMMUNITY" = "RAVEN"
        let currentTime = 0;
        for (let event of sectionsTrack) {
            if (event.type == "text") {
                if (event.text.includes("version:1")) {
                    type = "COMMUNITY"
                }
            }
            if (event.type != "noteOn" && event.type != "noteOff") continue // skip non-note events
            let delta = event.deltaTime * multiplier
            currentTime += delta

            if (rawSections[currentTime] == null) {
                rawSections[currentTime] = {
                    on: [],
                    off: []
                }
            }
            rawSections[currentTime][event.type == "noteOn" ? "on" : "off"].push(event.noteNumber)
        }

        return {
            sections: rawSections,
            type
        }
    }

    function processLyrics(lyricsTrack: midiParser.MidiEvent[], multiplier: number, ravenLyrics = false): SmuleLyricsData {
        let rawLyrics = []
        let currentLine = []
        let currentTime = 0
        let startTimeOfLyric = -1
        let syllableTimedLyrics = false

        for (let event of lyricsTrack) {
            if (event.type == "instrumentName" || ravenLyrics) {
                syllableTimedLyrics = true
                console.log("[SmuleMIDI] Ooo... we have syllable-timed lyrics!!!")
                continue
            }
            if (event.type != "lyrics") continue

            let text = cleanLyric(event.text, syllableTimedLyrics)

            let delta = event.deltaTime * multiplier
            currentTime += delta
            if (text == "") continue

            if (!syllableTimedLyrics) {
                rawLyrics.push({
                    text: [{
                        text: text,
                        startTime: currentTime,
                        endTime: currentTime + delta
                    }],
                    startTime: currentTime,
                    endTime: currentTime + delta,
                })
            } else {
                if (startTimeOfLyric == -1 && text != "*") {
                    startTimeOfLyric = currentTime
                }
                // Skip asterisks since i dont see what they're even all about
                // Maybe something related to pitches? Or accents? Since they seem
                // to be right when you should accentuate that specific syllable
                // Either way, useless for now
                if (text.includes("\\n")) {
                    if (text.replace("\\n", "") != "*") {
                        currentLine.push({
                            text: text.replace("\\n", ""),
                            startTime: currentTime,
                            endTime: currentTime + delta
                        })
                    }
                    rawLyrics.push({
                        text: currentLine,
                        startTime: startTimeOfLyric,
                        endTime: currentTime + delta,
                    })
                    currentLine = []
                    startTimeOfLyric = -1
                } else {
                    if (text == "*") continue
                    currentLine.push({
                        text: text,
                        startTime: currentTime,
                        endTime: currentTime + delta
                    })
                }
            }
        }

        return {
            lyrics: rawLyrics,
            isSyllable: syllableTimedLyrics
        }
    }

    function combineLyricsAndSections(lyrics: SmuleLyric[], sections: rawSmuleSections): SmuleLyric[] {
        let finalLyrics = []
        let lastPart = SmuleUserSinging.BOTH
        for (let lyric of lyrics) {
            let section = sections[lyric.startTime]
            try {
                if (section == null) {
                    let before = null
                    let beforeTime = 0
                    let after = null
                    let afterTime = 0
                    let smallestTime = 0
                    for (let [time, sect] of Object.entries(sections)) {
                        if (sect.on.length == 0) continue // skip note off sections
                        if (Number(time) > lyric.startTime) {
                            after = sect
                            afterTime = Number(time)
                            break
                        }
                        if (Number(time) < lyric.startTime) {
                            before = sect
                            beforeTime = Number(time)
                        }
                    }
                    if (before && after) {
                        if (Math.abs(beforeTime - lyric.startTime) < Math.abs(lyric.startTime - afterTime)) {
                            section = before
                            smallestTime = Math.abs(beforeTime - lyric.startTime)
                        } else {
                            section = after
                            smallestTime = Math.abs(afterTime - lyric.startTime)
                        }
                    } 
                    if (smallestTime > .75) {
                        console.warn("[SmuleMIDI] No section found for lyric at time", lyric.startTime, " - Supposing its the same part as the last lyric")
                        finalLyrics.push({
                            ...lyric,
                            part: lastPart
                        })
                        continue
                    }
                }
            } catch (e) {
                console.error("[SmuleMIDI] Skipped lyric because of:", e)
            }
            
            let part = null
            if (section) {
                if (!section.on) {
                    section.on = []
                }
                switch (section.on.length) {
                    case 4:
                        part = SmuleUserSinging.PART_TWO
                        break;
                    case 3:
                        part = SmuleUserSinging.PART_ONE
                        break;
                    case 2:
                    default:
                        part = SmuleUserSinging.BOTH
                }
    
                lastPart = part
            } else {
                console.warn("[SmuleMIDI] Section not available? Assuming it's the same part as the other one...")
                part = lastPart
            }

            finalLyrics.push({
                ...lyric,
                part
            })
        }

        return finalLyrics
    }

    function processRawPitches(pitchesTrack: midiParser.MidiEvent[], multiplier: number) {
        let rawPitches: {[time: number]: {on: number[], off: number[]}} = {}
        let currentTime = 0
        let largestNote = 0
        let smallestNote = Infinity
        for (let event of pitchesTrack) {
            if (event.type != "noteOn" && event.type != "noteOff") {
                continue
            }
            currentTime += event.deltaTime * multiplier
            if (!rawPitches[currentTime]) rawPitches[currentTime] = {on: [], off: []}
            rawPitches[currentTime][event.type == "noteOn" ? "on" : "off"].push(event.noteNumber)
            largestNote = Math.max(largestNote, event.noteNumber)
            smallestNote = Math.min(smallestNote, event.noteNumber)
        }

        return {
            rawPitches,
            largestNote,
            smallestNote
        }
    }

    function processPitches(rawPitches: {[time: number]: {on: number[], off: number[]}}, lyrics: SmuleLyric[]) {
        let pitches = []
        let currentPitch = {
            noteNumber: 0,
            startTime: 0,
            endTime: 0,
            part: SmuleUserSinging.BOTH
        }
        for (let [time, pitch] of Object.entries(rawPitches)) {
            if (pitch.off.length > 0) {
                pitches.push({
                    ...currentPitch,
                    endTime: Number(time)
                })
            }

            let part = SmuleUserSinging.BOTH
            for (let lyric of lyrics) {
                for (let text of lyric.text) {
                    if (text.startTime <= Number(time)) {
                        part = lyric.part
                    }
                }
            }

            currentPitch = {
                noteNumber: pitch.on[0],
                startTime: Number(time),
                endTime: Number(time),
                part
            }
        }

        return pitches
    }

    export function fetchPitchesFromMIDI(midi: Uint8Array, lyrics: SmuleLyric[]): SmulePitchesData {
        let midiArr = midiParser.parseMidi(midi)

        // default tempo is 500k
        let multiplier = 500_000 / (midiArr.header.ticksPerBeat * 1_000_000)

        let rawPitches = {rawPitches: {}, largestNote: 0, smallestNote: 0}
        for (let track of midiArr.tracks) {
            try {
                //* Calculate timing stuff
                for (let event of track) {
                    if (event.type == "setTempo") {
                        multiplier = event.microsecondsPerBeat / (midiArr.header.ticksPerBeat * 1_000_000)
                        break
                    }
                }
                let trackName = ""
                for (let event of track) {
                    if (event.type == "trackName") {
                        trackName = event.text
                        break
                    }
                }
                if (trackName == "Pitch") {
                    rawPitches = processRawPitches(track, multiplier)
                }
            } catch (e) {
                console.error("[SmuleMIDI] Skipped track because of:", e)
            }
        }

        let pitches = processPitches(rawPitches.rawPitches, lyrics)

        return {
            smallestNote: rawPitches.smallestNote,
            largestNote: rawPitches.largestNote,
            pitches
        }
    }

    export function fetchLyricsFromMIDI(midi: Uint8Array): SmuleMidiData {
        let midiArr = midiParser.parseMidi(midi)

        // default tempo is 500k
        let multiplier = 500_000 / (midiArr.header.ticksPerBeat * 1_000_000)

        //TODO: Test this out for groups too, since i've only tested duets
        let rawLyrics: SmuleLyric[] = null
        let rawSections: rawSmuleSectionsData = null
        let rawPitches = {rawPitches: {}, largestNote: 0, smallestNote: 0}
        let isSyllable = false
        for (let track of midiArr.tracks) {
            try {
                //* Calculate timing stuff
                for (let event of track) {
                    if (event.type == "setTempo") {
                        multiplier = event.microsecondsPerBeat / (midiArr.header.ticksPerBeat * 1_000_000)
                        break
                    }
                }
                let trackName = ""
                for (let event of track) {
                    if (event.type == "trackName") {
                        trackName = event.text
                        break
                    }
                }

                if (trackName == "Lyrics") {
                    let processed = processLyrics(track, multiplier, rawSections?.type == "RAVEN")
                    rawLyrics = processed.lyrics
                    isSyllable = processed.isSyllable
                } else if (trackName == "Sections") {
                    rawSections = processSections(track, multiplier)
                } else if (trackName == "Pitch") {
                    rawPitches = processRawPitches(track, multiplier)
                }
            } catch (e) {
                console.error("[SmuleMIDI] Skipped track because of:", e)
            }
        }

        if (!rawLyrics || !rawSections) {
            console.warn("[SmuleMIDI] No lyrics or sections found in MIDI file. Are you sure we have lyrics?")
        }
        
        let lyrics = combineLyricsAndSections(rawLyrics, rawSections.sections)
        let pitches = processPitches(rawPitches.rawPitches, lyrics)

        return {
            lyrics,
            pitches: {
                pitches,
                largestNote: rawPitches.largestNote,
                smallestNote: rawPitches.smallestNote
            },
            isSyllable,
            type: rawSections.type
        }
    } 
}