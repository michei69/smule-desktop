// ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⡟⠀⢸⡀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠋⠁⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡆⣠⠞⢡⠀⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⢰⡇⠀⠀⣇⠀⠀⠀⠈⠻⢷⣤⡀⠀⠀⠀⠀⠀⠀⣠⠶⠋⠀⠀⠀⠀⠀⠀⠀⣰⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⢚⣿⠞⠁⠀⢸⡄⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢸⡇⠀⠈⣿⠀⠀⠀⠀⠀⠀⠙⠻⢷⣦⣀⣀⡴⠋⠁⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠉⠀⠀⠀⣾⣇⠀⠈⡆
// ⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⢸⡁⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠛⠀⠀⠀⠀⢀⣀⠤⠔⠛⠁⣠⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡞⠀⠀⠀⠀⣰⠇⣿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⢸⡇⠀⠀⠀⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⢠⠴⢻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⣠⠏⠀⢿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠈⣇⠀⠀⠀⢮⡳⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⢠⣤⣤⣤⣤⠶⠛⠉⠀⠀⠀⠀⠀⡴⠋⠀⠀⣼⠀⠀⢻
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢹⡄⠀⠀⢸⡏⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠾⠯⠶⢻⠂⠀⠀⠈⠉⠻⠦⣄⣀⠀⠀⠀⠀⡴⢋⣴⠆⠀⠀⣿⠀⠀⣼
// ⠀⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⠳⡄⠀⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡀⢀⣀⠀⣀⡞⠀⠀⢀⣀⣀⣀⠀⠀⠉⠉⠛⣲⡾⠟⢹⠃⠀⠀⠀⣿⠀⠀⡟
// ⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠹⡦⠤⠤⠿⠦⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⠀⠈⠉⠁⠀⡤⠚⠋⠉⠀⠙⠻⣦⠀⣠⠞⠃⠀⠀⡿⠀⠀⠀⢸⠏⠀⢀⡇
// ⠀⠀⠀⠀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡽⠚⠁⠀⠀⠀⢠⡇⢀⣠⣄⡼⠀⠀⡾⠁
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠈⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠲⠤⠤⠤⠖⠒⠚⣩⣽⡿⠀⠀⠀⢀⣠⡾⠓⢉⣟⡾⠃⢀⡼⠁⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣷⡶⠮⣷⣄⠀⠀⠀⠈⠙⠆⠀⠿⠶⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⠿⠋⠁⠀⠀⠀⠀⠈⠀⢀⣴⠟⢋⣠⣶⣋⣀⣀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⡀⠀⠈⠳⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢷⣦⡑⢄⠀⠀⠀⠀⠀⠀⠀⢰⠂⣠⣶⠟⠋⠀⠀⠀⠀⣀⣀⡀⠀⠀⠋⠉⠀⠉⠁⠀⠀⣠⡾⠋⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⣄⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣈⡻⣮⣧⠀⠀⠀⠀⠀⠀⣿⣾⣋⣀⣤⣴⣶⠿⠿⠟⠛⠛⠃⠀⠀⠷⢤⣄⣀⣀⣤⣞⣡⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⣷⠶⠭⠿⠶⠒⠒⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⣻⣿⣿⠦⠖⠒⠒⠒⠶⣿⣿⡛⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣩⡿⠛⠁⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⣏⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠉⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⢀⣤⡴⠛⠉⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⢦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠿⠁⠈⠳⣄⣀⡀⢀⣀⣠⠾⠁⠀⠀⠀⠀⠀⠀⣀⣾⠏⠀⠀⢠⣶⢿⣯⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠋⢉⣁⣀⣀⠀⠀⠀⠸⣆⠀⠀⠀⠀⠀⠀⠀⠈⠉⡏⠁⠀⠀⠀⠀⢀⣀⣠⣴⠾⡟⠁⠀⠒⢻⡟⠀⠀⠀⠙⠻⣦⡀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⠀⠀⠈⠻⣄⡀⠀⠀⠀⠀⠻⣄⠀⠀⠀⠀⠀⣀⣤⡶⢿⠛⠛⠛⠛⠛⠛⢻⠁⠙⠲⠇⠀⠀⠴⢯⡤⠻⢶⣤⣄⣀⣈⣷⡀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⣥⡀⠀⠀⠀⠀⠸⡞⠛⠒⠂⠀⠀⠀⢯⣻⠶⣶⠶⠟⠋⠁⠀⠘⡆⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⡴⠊⠁⠀⠈⠙⢮⡉⠉⠛⠁⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠲⢶⡶⠟⠲⠤⡄⠀⠀⠀⠈⠁⠀⠈⣆⠀⠀⠀⠀⠀⠙⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠈⠁⢀⣠⣤⠤⠶⠶⠦⢽⡇⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⣀⠀⠀⠀⠀⣀⣠⠞⠁⠀⠀⠀⠀⣀⣴⣞⣉⣀⣀⣀⣀⣴⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣥⡤⢤⣤⣤⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠋⠉⠀⠀⠀⢀⣠⠴⠛⠁⠀⠀⠈⠀⠀⣠⠼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⣛⠛⠋⠉⠉⠀⠀⠈⠉⠛⠓⠶⠦⢤⣤⣀⣀⣀⣀⠀⠀⣀⣠⣴⣶⣾⠋⠁⢀⣀⣀⣀⡀⢠⣴⣞⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⠦⠽⠗⢲⣤⣶⠶⠚⠛⠳⢶⣦⣄⡀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣧⡶⠟⠛⠉⠉⠙⠛⢶⣅⠉⠙⠓⠶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⡄⠀⢀⣿⠋⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⣄⠈⠙⠛⠻⠟⠛⢫⣵⠾⢋⠏⠀⠀⠀⠀⠀⠀⢠⡏⠙⣷⠀⢠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⣸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⡄⠀⠀⢀⣴⠟⠁⢀⡎⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠸⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠸⣿⡛⠷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡇⠀⠀⢀⣀⣀⠀⠀⣀⠀⠀⠀⠀⠈⢻⣧⣀⡾⠃⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⡸⠀⠀⠀⠀⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣄⣀⠘⢷⡄⠀⠙⠳⣄⠀⠀⠀⠀⢀⡴⢻⡇⣠⠞⠋⠉⠉⠛⢯⡝⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⣿⠸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠉⠙⠓⢾⣷⡀⠀⠀⠘⢷⠀⢀⡴⠋⢀⣼⡷⠋⠀⠀⠀⠀⠀⠀⠹⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⣠⠃⠀⠀⠀⠀⢀⣿⠀⠹⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠈⠉⠀⠀⠀⢸⡾⠋⠀⠀⢸⡟⠁⠀⠀⠀⠀⠀⠀⠀⣀⣯⣤⣄⡀⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⢰⠏⠀⠀⠀⠀⢀⣼⠋⠀⠀⢹⣧⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣴⠟⠀⢸⠓⢶⠋⢀⠀⠀⠀⠀⠀⣠⡴⠋⠁⠀⠀⠀⠹⣦⢤⡤⠀⠀⡾⠀⠀⠀⠀⢠⢄⣠⠇⠀⠀⠀⠀⢀⣾⠃⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⢸⠀⢸⣟⣹⡟⠀⠀⠀⠈⢁⡀⠀⠀⠀⠀⠀⠀⣿⠋⠀⠀⡺⠁⠀⠀⠀⢀⣼⡟⠛⠉⠉⠛⠛⠦⣞⡁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀
//                             yapper
//             (get it? cause you yap in the chat?)

import { Client, client, xml } from "@xmpp/client"
import { SmuleUrls } from "./smule-urls"
import EventEmitter from "events"
import { Element } from "@xmpp/xml"
import { JID } from "@xmpp/jid"

export type SmuleMessage = {
    content: string,
    sender: number, // UUID, not JID
}
export type SmuleChatContainer = {
    messages: Array<SmuleMessage>
}

export class SmuleChat {
    public client: Client
    public static events: EventEmitter = new EventEmitter()
    private jid: JID

    private chats: Map<number, SmuleChatContainer> = new Map()

    constructor(userId: number, session: string, host = SmuleUrls.userChat) {
        this.client = client({
            service: "xmpp://" + host,
            domain: host,
            resource: "smule" + Math.random().toString(16).substring(2, 8), // literally doesnt matter
            username: userId + "",
            password: session
        })

        this.client.on("close", this.onClose)
        this.client.on("closing", this.onClosing)
        this.client.on("connect", this.onConnect)
        this.client.on("connecting", this.onConnecting)
        this.client.on("disconnect", this.onDisconnect)
        this.client.on("disconnecting", this.onDisconnecting)
        this.client.on("error", this.onError)
        // this.client.on("input", this.onInput)
        this.client.on("nonza", this.onNonza)
        this.client.on("offline", this.onOffline)
        this.client.on("online", this.onOnline)
        this.client.on("open", this.onOpen)
        this.client.on("opening", this.onOpening)
        this.client.on("send", this.onSend)
        this.client.on("stanza", (el) => this.onStanza(el))
    }

    /**
     * Connect to the XMPP server and log in as the specified user
     *
     * @returns The JID of the connected user
     */
    public async connect() {
        this.jid = await this.client.start()
        _log("Connected as:", this.jid.getLocal() + "@" + this.jid.getDomain())
        this.client.send(xml("presence", {}))
    }

    /**
     * Send a chat state to the server. This is used to
     * signal whether you are currently active or not.
     *
     * active -> You're active
     * composing -> Typing
     * paused -> Just stopped typing
     * inactive -> You're inactive
     * gone -> You're hidden / disconnected
     * 
     * @param state One of "active", "composing", "paused", "inactive", or "gone"
     * @default "active"
     */
    public async sendChatState(state: "active" | "composing" | "paused" | "inactive" | "gone" = "active") {
        await this.client.send(
            xml(
                "message",
                { to: this.jid, type: "chat" },
                xml(
                    "chatstate",
                    { xmlns: 'http://jabber.org/protocol/chatstates' },
                    state
                )
            )
        )
    }
    /**
     * Fetches the message history with the specified user
     * @param jid The JID of the user to fetch the message history with
     * @param limit The maximum number of messages to fetch. Default is 50.
     */
    public async fetchMessageHistory(jid: JID | string, limit = 50, before = null, after = null) {
        _log(`Loading ${limit} messages with ${jid}...`)
        await this.client.send(
            xml(
                'iq',
                { type: 'set', id: 'mam-query' },
                xml(
                    'query',
                    { xmlns: 'urn:xmpp:mam:2' },
                    xml('set', { xmlns: 'http://jabber.org/protocol/rsm' },
                        xml('max', {}, limit.toString()),
                        before ? xml('before', {}, before.toString()) : null,
                        after ? xml('after', {}, after.toString()) : null
                    ),
                    xml('with', {}, jid.toString())
                )
            )
        )
    }
    public async sendTextMessage(jid: JID | string, message: string) {
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: "chat" },
                xml("body", {}, message)
            )
        )
    }
    public async sendPerformanceMessage(jid: JID | string, performanceKey: string) {
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: "chat" },
                xml(
                    "performance", 
                    { xmlns: "urn:x-smule:xmpp" }, 
                    xml(
                        "key", 
                        {}, 
                        performanceKey
                    )
                ),
                xml("body", {}, "")
            )
        )
    }


    /**
     * Read-only jid to prevent any bugs
     * @returns user's JID
     */
    public fetchJID() {
        return this.jid
    }

    private onClose(el: Element) {
        _log("Closed!:", el)
        SmuleChat.events.emit("close")
    }
    private onClosing(el: Element) {
        _log("Closing!:", el)
        SmuleChat.events.emit("closing")
    }
    private onConnect() {
        _log("Connected!")
        SmuleChat.events.emit("connected")
    }
    private onConnecting(el: Element) {
        _log("Connecting!:", el)
        SmuleChat.events.emit("connecting")
    }
    private onDisconnect(el: Element) {
        _log("Disconnected!:", el)
        SmuleChat.events.emit("disconnected")
    }
    private onDisconnecting(el: Element) {
        _log("Disconnecting!:", el)
        SmuleChat.events.emit("disconnecting")
    }
    private onError(el: Element) {
        _error("Error!:", el)
        SmuleChat.events.emit("error", el)
    }
    private onNonza(el: Element) {
        switch (el.getName()) {
            case "stream:features":
                _log("Got XMPP features!")
                break
            case "proceed":
                _log("Got XMPP proceed!")
                break
            default:
                _log("Nonza!")
                break
        }
    }
    private onOffline(el: Element) {
        _log("Offline!:", el)
        SmuleChat.events.emit("offline")
    }
    private onOnline(el: Element) {
        _log("Online!:", el)
        SmuleChat.events.emit("online")
    }
    private onOpen(el: Element) {
        _log("Open!")
        SmuleChat.events.emit("open")
    }
    private onOpening() {
        _log("Opening!")
        SmuleChat.events.emit("opening")
    }
    private onSend(el: Element) {
        if (el.getName() == "starttls") {
            _log("Sending TLS stuff!")
        } else {
            _log("Sent stuff!")
        }
    }
    private onStanza(el: Element) {
        if (el.is("message")) {
            this.parseMessage(el)
        } else {
            _log("Stanza!", el.toString())
        }
    }

    private getUserIdFromJID(jid: string) {
        return parseInt(jid.split("@")[0])
    }
    private parseMessage(el: Element) {
        if (el.children.length < 1) return
        _log(el.toString())

        let child = el.getChildByAttr("xmlns", "http://jabber.org/protocol/chatstates")
        if (child) {
            _log("Got chatstate!", child.getName())
            SmuleChat.events.emit("chatstate", child.getName())
        }

        child = el.getChildByAttr("xmlns", "urn:xmpp:receipts")
        if (child) {
            _log("Got receipt!", child.getName())
            SmuleChat.events.emit("receipt", child.getName())
        }

        child = el.getChild("body")
        if (child && child.getText().trim().length > 0) {
            _log("Got message!", child.getText())
            let data = {
                message: child.getText(),
                user: this.getUserIdFromJID(el.getAttr("from"))
            }
            SmuleChat.events.emit("message", data)
            if (!this.chats.has(data.user)) this.chats.set(data.user, { messages: [] })
            this.chats.get(data.user)?.messages.push({
                content: data.message,
                sender: data.user
            })
            return
        }

        child = el.getChild("performance")
        if (child) {
            _log("Got performance!", child.toString())
        }

        child = el.getChild("result")
        if (!child) return _log(el.toString())
        child = child.getChild("forwarded")
        if (!child) return _log(el.toString())
        child = child.getChild("message")
        if (!child) return _log(el.toString())
        child = child.getChild("body")
        if (!child) return _log(el.toString())
        _log("Got message history!", child.getText())
        let data = {
            message: child.getText(),
            user: this.getUserIdFromJID(child.parent.getAttr("from"))
        }
        SmuleChat.events.emit("history", data)
        if (!this.chats.has(data.user)) this.chats.set(data.user, { messages: [] })
        this.chats.get(data.user)?.messages.push({
            content: data.message,
            sender: data.user
        })
    }

    public getChats() { return this.chats }
}

//#region Logging
function _log(...args: any) {
    console.log("[SmuleChat]", ...args)
}
function _warn(...args: any) {
    console.warn("[SmuleChat]", ...args)
}
function _error(...args: any) {
    console.error("[SmuleChat]", ...args)
}
//#endregion
