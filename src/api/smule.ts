// TODO: WIP!!

// ⠀⠀⠀⠀⠀⠀⠀⠙⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢺⣿⣿⡆⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⡇⠀⠀⠀⠀⠀⠀⣾⢡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣷⡦⠀⠀⠀⠀⢰⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠃⣠⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣆⠀⠀⠀⣾⣿⣿⣿⣷⠄⠀⠰⠤⣀⠀⠀⣴⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠃⢺⣿⣿⣿⣿⡄⠀⠀⣿⣿⢿⣿⣿⣦⣦⣦⣶⣼⣭⣼⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣷⡆⠂⣿⣿⣞⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢙⣿⣿⣿⣿⣷⠸⣿⣿⣿⣿⣿⣿⠟⠻⣿⣿⣿⣿⡿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⢿⣿⣿⣿⣿⡄⣿⣿⣿⣿⣿⣿⡀⢀⣿⣿⣿⣿⠀⢸⣿⣿⠅⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⡀⣠⣾⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⢁⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠠⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣀⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣻⣿⣿⣿⣿⣿⡟⠋⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠙⢿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⠿⢿⡿⠛⠋⠁⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣅⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⡟⠃⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣿⣿⣿⣿⣿⣤⡀⠀⠀⠀
// ⠀⠜⢠⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣦⠄⣠⠀
// ⠠⢸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⠛⣿⣿⣿⡿⠏⠀⠀⠀⠀⠀⠀⢳⣾⣿⣿⣿⣿⣿⣿⡶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿
// ⠀ ⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⡿⡿⠿⠛⠙⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⠏⠉⠻⠿⠟⠁
import { AccountIcon, ApiResponse, ArrResult, AutocompleteResult, CategorySongsResult, LoginAsGuestResult, LoginResult, PerformanceByKeysResult, PerformanceList, PerformanceReq, PerformanceResult, PerformancesByUserResult, PerformancesFillStatus, PerformancesSortOrder, ProfileResult, SearchResult, SearchResultSort, SearchResultType, SmuleErrorCode, SmuleSession, SongbookResult, TrendingSearchResult, UsersLookupResult } from "./smule-types";
import * as crypto from "crypto";
import axios, { AxiosResponse } from "axios";
import * as midiParser from "midi-file";
import { SmuleUtil, Util } from "./util";
import { SmuleUrls } from "./smule-urls";
import { AutocompleteRequest, CategorySongsRequest, LoginAsGuestRequest, LoginRefreshRequest, LoginRequest, PerformancesByUserRequest, PerformancesListRequest, SearchRequest, SongbookRequest } from "./smule-requests";

const APP_VERSION = "12.0.5"

class InvalidParametersError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "InvalidParametersError"
    }
}
class NotImplementedError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "NotImplementedError"
    }
}

/**
 * Namespace for Smule's digest parameter found in http requests
 * 
 * Basically, it takes in certain "required" parameters, the body,
 * and a few more pieces of data, alongside the path; concatenates them
 * together, prepends a static salt, and then creates a sha1 digest
 */
export namespace SmuleDigest {
    const SALT = `c2250918de500e32c37842f2d25d4d8210992a0ae96a7f36c4c9703cc675d02b92968bc4fa7feada`
    export function _calculateDigest(encodedPath: string, digestParameters: string): string {
        const shasum = crypto.createHash("sha1")
        return shasum.update(SALT + encodedPath + digestParameters).digest("hex")
    }
    function _getDigestParameters(
        parameters: {[key: string]: string},
        needsSession = false,
        isGetRequest = false, 
        multiPartBody: string = "",
    ) {
        let neededParameters = {}
        let required = ["appVersion", "app", "appVariant", "msgId"]
        if (needsSession) required.push("session")

        for (let param of required) {
            if (!parameters[param])
                throw new InvalidParametersError(`Missing parameter ${param}`)
            
            neededParameters[param] = parameters[param]
        }
        if (parameters["ftrack"]) neededParameters["ftrack"] = parameters["ftrack"]
        
        if (isGetRequest) {
            for (let param of Object.keys(parameters)) {
                neededParameters[param] = parameters[param]
            }
        }
        if (multiPartBody != "") {
            // TODO: handle multipart digest
        }

        return neededParameters
    }
    function _runDigestCalculation(
        parameters: {[key: string]: string},
        urlPath: string,
        body = ""
    ) {
        let tempString = ""
        for (let name of Object.keys(parameters).sort()) {
            tempString += name + parameters[name]
        }
        if (body != "") tempString += body

        // console.log(urlPath, tempString, body)
        return _calculateDigest(urlPath, tempString)
    }

    /**
     * Calculates the SHA1 digest required for
     * HTTP requests to smule's api
     * 
     * @param urlPath The path of the request
     * @param parameters The query parameters of the request
     * @param body The body of the request
     * @param needsSession Whether or not session is required for this request
     * @param isGetRequest Whether or not this is a GET request
     * @param isMultiPartBody Whether or not the body is multipart
     * @returns SHA1 digest
     */
    export function calculateDigest(
        urlPath: string,
        parameters: {[key: string]: string}|URLSearchParams,
        body = "",
        needsSession = false,
        isGetRequest = false,
        isMultiPartBody = false
    ) {
        if (parameters instanceof URLSearchParams) parameters = Util.queryToObject(parameters)
        urlPath = Util.getPathFromFullUrl(urlPath)
        let digestParameters = _getDigestParameters(parameters, needsSession, isGetRequest, isMultiPartBody ? body : "")
        return _runDigestCalculation(digestParameters, urlPath, body)
    }
}

//#region Logging
function _log(...args: any) {
    console.log("[SmuleAPI]",...args)
}
function _warn(...args: any) {
    console.warn("[SmuleAPI]",...args)
}
function _error(...args: any) {
    console.error("[SmuleAPI]",...args)
}
//#endregion

/**
 * The public interface for Smule's API
 */
export class Smule {
    session = new SmuleSession()
    private msgId = 1000
    private ax = axios.create({
        validateStatus: () => true
    })
    
    constructor() {}


    
    /**
     * @returns Whether or not the request has been successful 
     */
    private _handleNon200(response: AxiosResponse): boolean {
        if (response.status == 200) {
            let data: ApiResponse<any> = response.data
            if (data.status.code == 0) return true
            else {
                _warn(`[${response.request.path}] Got ${data.status.code} - ${data.status.message ?? SmuleErrorCode[data.status.code]}`)
                _warn(data)
                _warn(response.config.data)
                return false
            }
        }
        
        if (response.request && response.request.path) {
            _warn(`[${response.request.path}] Got ${response.status} - ${response.statusText}`)
            _warn(response.data)
        } else {
            _warn(`[NO REQUEST?] Got ${response.status} - ${response.statusText}`)
            _warn(response.data)
        }
        return false
    }
    private async _createRequest(url: string, body: any, isJson = true, isGetRequest = false, checkSession = true) {
        // _log(`[${url}] ${isJson} ${isGetRequest} ${checkSession} --- ${body}`)
        
        let params = new URLSearchParams()
        params.append("app", "sing_google")
        params.append("appVariant", "1")
        params.append("appVersion", APP_VERSION)
        params.append("msgId", this.msgId.toString())
        if (checkSession && this.session && this.session.sessionToken && !this.session.expired) {
            params.append("session", this.session.sessionToken)
        }

        if (typeof body == "object") body = JSON.stringify(body)

        let digest = SmuleDigest.calculateDigest(url, params, body, checkSession && params.has("session"), isGetRequest, isJson)
        params.append("digest", digest)

        let headers = {
            "Accept-Encoding": "gzip",
            "Connection": "keep-alive",
            "Content-Type": isJson ? "application/json" : "", // TODO
            "User-Agent": "com.smule.singandroid/" + APP_VERSION + " (9,SM-S908E,en_US)"
        }

        this.msgId++
        
        if (isJson) {
            return this.ax.post(url + `?${params.toString()}`, body, {
                headers,
            })
        } else {
            throw new NotImplementedError("TODO: handle non-JSON and GET requests")
        }
    }
    private _getResponseData<T>(response: AxiosResponse) {
        let data = response.data as ApiResponse<T>
        return data.data as T
    }

    /**
     * Logs in as a guest
     * @returns Whether or not the login was successful
     */
    public async loginAsGuest() {
        let req = await this._createRequest(SmuleUrls.LoginGuest, new LoginAsGuestRequest(), true, false, false) 
        if (!this._handleNon200(req)) return false
        
        let res = this._getResponseData<LoginAsGuestResult>(req)
        //* Guests do not receive a refresh token
        this.session.sessionToken = res.loginResult.sessionToken
        this.session.isGuest = true
        this.session.expired = false

        _log(`Logged in as player ID ${res.loginResult.playerId} (GUEST)`)
        return true
    }
    /**
     * Look up a user by their email
     * 
     * Usually used for login, but who cares lol
     * @param email The email adress the user utilizes for their account
     * @returns The user's data
     */
    public async lookUpUserByEmail(email: string) {
        let req = await this._createRequest(SmuleUrls.UserLookup, {email}, true, false, false)
        if (!this._handleNon200(req)) return false
        return this._getResponseData<{accountIcon: AccountIcon, apps: string[]}>(req)
    }
    /**
     * Look up multiple accounts
     * @param accountIds An array of the accounts' IDs
     * @returns The accounts' details
     */
    public async lookUpUsersByIds(accountIds: number[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch accounts.")
            return
        }

        let req = await this._createRequest(SmuleUrls.AccountLookup, {accountIds})
        if (!this._handleNon200(req)) return
        return this._getResponseData<UsersLookupResult>(req)
    }
    /**
     * Looks up a single account
     * @param accountId The account's id
     * @returns The account's details
     */
    public async lookUpUserById(accountId: number) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch accounts.")
            return
        }
        
        let data = await this.lookUpUsersByIds([accountId])
        return data!.accountIcons[0]
    }
    /**
     * Log into your account
     * @param email Your email address
     * @param password Your smule account's password
     * @returns Whether the log in was successful
     */
    public async login(email: string, password: string) {
        let req = await this._createRequest(SmuleUrls.UserLogin, new LoginRequest(email, password), true, false, false)
        if (!this._handleNon200(req)) return false
        let res = this._getResponseData<LoginResult>(req)
        this.session.sessionToken = res.sessionToken
        this.session.refreshToken = res.refreshToken
        this.session.expired = false
        this.session.isGuest = false
        _log(`Logged in as ${res.handle} (${res.playerId})`)
        return true
    }
    

    /**
     * Refreshes the session token
     * @returns Whether or not the refresh was successful
     */
    public async refreshLogin() {
        if (!this.session.isGuest) {
            _error("Guests are not allowed to refresh their login.")
            return false
        }
        if (!this.session.refreshToken) {
            _error("Requested to refresh login but no refresh token found. Did you even log in?")
            return false
        }
        if (!this.session.expired) {
            _warn("Refreshing login although session isnt expired?")
            this.session.expired = true // Must be expired in order to refresh
        }
    
        let req = await this._createRequest(SmuleUrls.LoginRefresh, new LoginRefreshRequest(this.session.refreshToken), true, false, false)
        if (!this._handleNon200(req)) return false

        let res = this._getResponseData<{loginResult: LoginResult}>(req)

        this.session.sessionToken = res.loginResult.sessionToken
        this.session.refreshToken = res.loginResult.refreshToken
        this.session.expired = false
        
        _log(`Refreshed login with player ID ${res.loginResult.playerId}`)
        return true
    }

    private isLoggedIn() {
        return SmuleUtil.checkLoggedIn(this.session)
    }


    /**
     * Fetch recommended songs, which appear on the front page
     * @param cursor Paging
     * @param limit How many per page
     * @returns The "song book"
     */
    public async getSongBook(cursor = "start", limit = 10) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to get a song book.")
            return
        }

        let req = await this._createRequest(this.session.isGuest ? SmuleUrls.SongbookGuest : SmuleUrls.Songbook, new SongbookRequest(cursor, limit))
        if (!this._handleNon200(req)) return
        return this._getResponseData<SongbookResult>(req)
    }

    /**
     * Fetch songs from a certain category
     * @param cursor Paging
     * @param categoryId The category's id
     * @param limit How many per page
     * @returns The songs
     */
    public async getSongsFromCategory(cursor = "start", categoryId = 9998, limit = 10) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch songs.")
            return
        }

        let req = await this._createRequest(SmuleUrls.Category, new CategorySongsRequest(cursor, limit, categoryId))
        if (!this._handleNon200(req)) return
        return this._getResponseData<CategorySongsResult>(req)
    }


    /**
     * Look up multiple performances at once
     * @param performanceKeys An array of performance keys
     * @returns The performances' details
     */
    public async lookUpPerformancesByKeys(performanceKeys: string[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceByKeys, {performanceKeys})
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformanceByKeysResult>(req)
    }
    /**
     * Looks up a single performance
     * @param performanceKey The performance key
     * @returns The performance's details
     */
    public async lookUpPerformanceByKey(performanceKey: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let data = await this.lookUpPerformancesByKeys([performanceKey])
        return data!.performanceIcons[0]
    }
    /**
     * Look up performances by a specific user
     * 
     * @param accountId The account ID of the user whose performances are to be fetched
     * @param limit The maximum number of performances to fetch (default is 20)
     * @param offset The starting point for fetching performances (default is 0)
     * @returns The user's performances details
     */
    public async lookUpPerformancesByUser(accountId: number, limit = 20, offset = 0) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceParts, new PerformancesByUserRequest(accountId, limit, offset))
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformancesByUserResult>(req)
    }
    /**
     * Retrieves a list of performances based on the specified criteria.
     * 
     * @param sort The order in which to sort the performances (default is SUGGESTED).
     * @param fillStatus The fill status of the performances (default is ACTIVESEED).
     * @param limit The maximum number of performances to fetch (default is 20).
     * @param offset The starting point for fetching performances (default is 0).
     * @returns An object containing an array of performance icons and the next offset.
     */
    public async listPerformances(sort = PerformancesSortOrder.SUGGESTED, fillStatus = PerformancesFillStatus.ACTIVESEED, limit = 20, offset = 0) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceList, new PerformancesListRequest(sort, fillStatus, limit, offset))
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformanceList>(req)
    }
    /**
     * Retrieves a list of performances based on the specified criteria.
     * 
     * @param requests An array of PerformanceReq objects. Each object contains the criteria for fetching performances.
     * @returns An object containing an array of performance lists.
     */
    public async requestListsOfPerformances(requests: PerformanceReq[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }
        if (requests.length < 1) {
            _error("You must specify at least one performance request.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceLists, {perfRequests: requests})
        if (!this._handleNon200(req)) return
        return this._getResponseData<{perfLists: PerformanceList[]}>(req)
    }
    public async fetchPerformance(performanceKey: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch a performance.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceUrl, {performanceKey})
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformanceResult>(req)
    }

    /**
     * Fetches a song using the specified key.
     * 
     * @param key The key associated with the song to be fetched.
     * @returns The details of the song
     */
    public async fetchSong(key: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch a song.")
            return
        }

        let req = await this._createRequest(SmuleUrls.Arr, {arrKey: key})
        if (!this._handleNon200(req)) return
        return this._getResponseData<ArrResult>(req)
    }

    /**
     * Fetches your profile
     * @returns Your profile
     */
    public async fetchSelf() {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch yourself.")
            return
        }
        if (this.session.isGuest) {
            _error("You must be logged in as a user in order to fetch yourself.")
            return
        }

        let req = await this._createRequest(SmuleUrls.UserProfileMe, {includeActiveState: false})
        if (!this._handleNon200(req)) return
        return this._getResponseData<ProfileResult>(req)
    }


    /**
     * Fetches the current trending searches on Smule.
     * @returns The trending searches currently available
     */
    public async getTrendingSearches() {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch trending searches.")
            return
        }

        let req = await this._createRequest(SmuleUrls.TrendingSearches, {})
        if (!this._handleNon200(req)) return
        return this._getResponseData<TrendingSearchResult>(req)
    }
    /**
     * Searches on Smule
     * @param query The query to search for
     * @returns The search result
     */
    public async search(query: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to search.")
            return
        }

        let req = await this._createRequest(SmuleUrls.SearchGlobal, {includeRecording: 0, term: query})
        if (!this._handleNon200(req)) return
        return this._getResponseData<SearchResult>(req)
    }
    public async searchSpecific(query: string, type: SearchResultType, sort = SearchResultSort.POPULAR, cursor = "start", limit = 25) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to search.")
            return
        }

        let req = await this._createRequest(SmuleUrls.Search, new SearchRequest(cursor, limit, type, sort, query))
        if (!this._handleNon200(req)) return
        return this._getResponseData<SearchResult>(req)
    }
    /**
     * Gets autocomplete suggestions for a given query
     * @param query The query to get autocomplete suggestions for
     * @param limit The maximum number of suggestions to return (default is 5)
     * @returns The autocomplete suggestions
     */
    public async getAutocomplete(query: string, limit = 5) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to get autocomplete.")
            return
        }

        let req = await this._createRequest(SmuleUrls.SearchAutocomplete, new AutocompleteRequest(query, limit))
        if (!this._handleNon200(req)) return
        return this._getResponseData<AutocompleteResult>(req)
    }
}

//TODO: finish this lol
export namespace SmuleMIDI {
    export enum SmuleUserSinging {
        BOTH,
        PART_ONE,
        PART_TWO,
    }

    export type SmuleSyllable = {
        text: string,
        startTime: number,
        endTime: number
    }
    export type SmuleLyric = {
        text: Array<SmuleSyllable>,
        startTime: number,
        endTime: number,
        part: SmuleUserSinging
    }
    export type SmuleMidiData = {
        lyrics: Array<SmuleLyric>,
        pitches: SmulePitchesData,
        isSyllable: boolean
    }
    export type SmuleLyricsData = {
        lyrics: Array<SmuleLyric>,
        isSyllable: boolean
    }

    export type SmulePitch = {
        noteNumber: number,
        startTime: number,
        endTime: number,
        part: SmuleUserSinging|number
    }
    export type SmulePitchesData = {
        pitches: SmulePitch[],
        largestNote: number,
        smallestNote: number
    }
    type rawSmuleSections = {
        [key: string] : {
            on: Array<number>,
            off: Array<number>
        }
    }
    function cleanLyric(lyric: string, isSyllable = false) {
        lyric = Buffer.from(lyric, "ascii").toString("utf-8")
        if (isSyllable) return lyric

        return lyric.replaceAll("\\n", "") // remove newlines
                    .trim()
    }

    function processSections(sectionsTrack: midiParser.MidiEvent[], multiplier: number): rawSmuleSections {
        let rawSections = {}
        let currentTime = 0;
        for (let event of sectionsTrack) {
            if (event.type != "noteOn" && event.type != "noteOff") continue // skip non-note events
            let delta = event.deltaTime * multiplier
            currentTime += delta

            if (rawSections[currentTime] == null) {
                rawSections[currentTime] = {
                    on: [],
                    off: []
                }
            }
            rawSections[currentTime][event.type == "noteOn" ? "on" : "off"].push(event.noteNumber)
        }

        return rawSections
    }

    function processLyrics(lyricsTrack: midiParser.MidiEvent[], multiplier: number): SmuleLyricsData {
        let rawLyrics = []
        let currentLine = []
        let currentTime = 0
        let startTimeOfLyric = -1
        let syllableTimedLyrics = false

        for (let event of lyricsTrack) {
            if (event.type == "instrumentName") {
                syllableTimedLyrics = true
                console.log("[SmuleMIDI] Ooo... we have syllable-timed lyrics!!!")
                continue
            }
            if (event.type != "lyrics") continue

            let text = cleanLyric(event.text, syllableTimedLyrics)

            let delta = event.deltaTime * multiplier
            currentTime += delta
            if (text == "") continue

            if (!syllableTimedLyrics) {
                rawLyrics.push({
                    text: [{
                        text: text,
                        startTime: currentTime,
                        endTime: currentTime + delta
                    }],
                    startTime: currentTime,
                    endTime: currentTime + delta,
                })
            } else {
                if (startTimeOfLyric == -1 && text != "*") {
                    startTimeOfLyric = currentTime
                }
                // Skip asterisks since i dont see what they're even all about
                // Maybe something related to pitches? Or accents? Since they seem
                // to be right when you should accentuate that specific syllable
                // Either way, useless for now
                if (text.includes("\\n")) {
                    if (text.replace("\\n", "") != "*") {
                        currentLine.push({
                            text: text.replace("\\n", ""),
                            startTime: currentTime,
                            endTime: currentTime + delta
                        })
                    }
                    rawLyrics.push({
                        text: currentLine,
                        startTime: startTimeOfLyric,
                        endTime: currentTime + delta,
                    })
                    currentLine = []
                    startTimeOfLyric = -1
                } else {
                    if (text == "*") continue
                    currentLine.push({
                        text: text,
                        startTime: currentTime,
                        endTime: currentTime + delta
                    })
                }
            }
        }

        return {
            lyrics: rawLyrics,
            isSyllable: syllableTimedLyrics
        }
    }

    function combineLyricsAndSections(lyrics: SmuleLyric[], sections: rawSmuleSections): SmuleLyric[] {
        let finalLyrics = []
        let lastPart = SmuleUserSinging.BOTH
        for (let lyric of lyrics) {
            let section = sections[lyric.startTime]
            if (section == null) {
                let before = null
                let beforeTime = 0
                let after = null
                let afterTime = 0
                let smallestTime = 0
                for (let [time, sect] of Object.entries(sections)) {
                    if (sect.on.length == 0) continue // skip note off sections
                    if (Number(time) > lyric.startTime) {
                        after = sect
                        afterTime = Number(time)
                        break
                    }
                    if (Number(time) < lyric.startTime) {
                        before = sect
                        beforeTime = Number(time)
                    }
                }
                if (before && after) {
                    if (Math.abs(beforeTime - lyric.startTime) < Math.abs(lyric.startTime - afterTime)) {
                        section = before
                        smallestTime = Math.abs(beforeTime - lyric.startTime)
                    } else {
                        section = after
                        smallestTime = Math.abs(afterTime - lyric.startTime)
                    }
                } 
                if (smallestTime > .75) {
                    console.warn("[SmuleMIDI] No section found for lyric at time", lyric.startTime, " - Supposing its the same part as the last lyric")
                    finalLyrics.push({
                        ...lyric,
                        part: lastPart
                    })
                    continue
                }
            }
            // lastSection = section

            let part = SmuleUserSinging.PART_ONE
            if (section.on.includes(50) || section.on.includes(40)) {
                if (section.on.includes(51) || section.on.includes(42)) {
                    part = SmuleUserSinging.PART_TWO
                } else {
                    part = SmuleUserSinging.PART_ONE
                }
            } else {
                part = SmuleUserSinging.BOTH
            }

            lastPart = part

            finalLyrics.push({
                ...lyric,
                part
            })
        }

        return finalLyrics
    }

    function processRawPitches(pitchesTrack: midiParser.MidiEvent[], multiplier: number) {
        let rawPitches: {[time: number]: {on: number[], off: number[]}} = {}
        let currentTime = 0
        let largestNote = 0
        let smallestNote = Infinity
        for (let event of pitchesTrack) {
            if (event.type != "noteOn" && event.type != "noteOff") {
                continue
            }
            currentTime += event.deltaTime * multiplier
            if (!rawPitches[currentTime]) rawPitches[currentTime] = {on: [], off: []}
            rawPitches[currentTime][event.type == "noteOn" ? "on" : "off"].push(event.noteNumber)
            largestNote = Math.max(largestNote, event.noteNumber)
            smallestNote = Math.min(smallestNote, event.noteNumber)
        }

        return {
            rawPitches,
            largestNote,
            smallestNote
        }
    }

    function processPitches(rawPitches: {[time: number]: {on: number[], off: number[]}}, lyrics: SmuleLyric[]) {
        let pitches = []
        let currentPitch = {
            noteNumber: 0,
            startTime: 0,
            endTime: 0,
            part: SmuleUserSinging.BOTH
        }
        for (let [time, pitch] of Object.entries(rawPitches)) {
            if (pitch.on.length == 0) {
                pitches.push({
                    ...currentPitch,
                    endTime: Number(time)
                })
                continue
            }

            let part = SmuleUserSinging.BOTH
            for (let lyric of lyrics) {
                for (let text of lyric.text) {
                    if (text.startTime <= Number(time)) {
                        part = lyric.part
                    }
                }
            }

            currentPitch = {
                noteNumber: pitch.on[0],
                startTime: Number(time),
                endTime: Number(time),
                part
            }
        }

        return pitches
    }

    export function fetchLyricsFromMIDI(midi: Uint8Array): SmuleMidiData {
        let midiArr = midiParser.parseMidi(midi)

        // default tempo is 500k
        let multiplier = 500_000 / (midiArr.header.ticksPerBeat * 1_000_000)

        //TODO: Test this out for groups too, since i've only tested duets
        let rawLyrics = []
        let rawSections = {}
        let rawPitches = {rawPitches: {}, largestNote: 0, smallestNote: 0}
        let isSyllable = false
        for (let track of midiArr.tracks) {
            try {
                //* Calculate timing stuff
                for (let event of track) {
                    if (event.type == "setTempo") {
                        multiplier = event.microsecondsPerBeat / (midiArr.header.ticksPerBeat * 1_000_000)
                        break
                    }
                }
                let trackName = ""
                for (let event of track) {
                    if (event.type == "trackName") {
                        trackName = event.text
                        break
                    }
                }

                if (trackName == "Lyrics") {
                    let processed = processLyrics(track, multiplier)
                    rawLyrics = processed.lyrics
                    isSyllable = processed.isSyllable
                } else if (trackName == "Sections") {
                    rawSections = processSections(track, multiplier)
                } else if (trackName == "Pitch") {
                    rawPitches = processRawPitches(track, multiplier)
                }
            } catch (e) {
                console.error("[SmuleMIDI] Skipped track because of:", e)
            }
        }

        if (!rawLyrics || !rawSections) {
            console.warn("[SmuleMIDI] No lyrics or sections found in MIDI file. Are you sure we have lyrics?")
        }
        
        let lyrics = combineLyricsAndSections(rawLyrics, rawSections)
        let pitches = processPitches(rawPitches.rawPitches, lyrics)

        return {
            lyrics,
            pitches: {
                pitches,
                largestNote: rawPitches.largestNote,
                smallestNote: rawPitches.smallestNote
            },
            isSyllable
        }
    } 
}