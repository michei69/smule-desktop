// TODO: WIP!!

// ⠀⠀⠀⠀⠀⠀⠀⠙⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢺⣿⣿⡆⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⡇⠀⠀⠀⠀⠀⠀⣾⢡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣷⡦⠀⠀⠀⠀⢰⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠃⣠⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣆⠀⠀⠀⣾⣿⣿⣿⣷⠄⠀⠰⠤⣀⠀⠀⣴⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠃⢺⣿⣿⣿⣿⡄⠀⠀⣿⣿⢿⣿⣿⣦⣦⣦⣶⣼⣭⣼⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣷⡆⠂⣿⣿⣞⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢙⣿⣿⣿⣿⣷⠸⣿⣿⣿⣿⣿⣿⠟⠻⣿⣿⣿⣿⡿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⢿⣿⣿⣿⣿⡄⣿⣿⣿⣿⣿⣿⡀⢀⣿⣿⣿⣿⠀⢸⣿⣿⠅⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⡀⣠⣾⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⢁⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠠⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣀⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣻⣿⣿⣿⣿⣿⡟⠋⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠙⢿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⠿⢿⡿⠛⠋⠁⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣅⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⡟⠃⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣿⣿⣿⣿⣿⣤⡀⠀⠀⠀
// ⠀⠜⢠⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣦⠄⣠⠀
// ⠠⢸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⠛⣿⣿⣿⡿⠏⠀⠀⠀⠀⠀⠀⢳⣾⣿⣿⣿⣿⣿⣿⡶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿
// ⠀ ⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⡿⡿⠿⠛⠙⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⠏⠉⠻⠿⠟⠁
import { AccountIcon, ApiResponse, ArrResult, CategorySongsResult, LoginAsGuestResult, LoginResult, MidiFile, PerformanceByKeysResult, PerformanceIcon, PerformanceList, PerformanceReq, PerformancesByUserResult, PerformancesFillStatus, PerformancesSortOrder, ProfileResult, SmuleErrorCode, SmuleSession, SongbookResult, UsersLookupResult } from "./smule-types";
import * as crypto from "crypto";
import axios, { AxiosResponse } from "axios";
const midiParser = require("midi-parser-js");
import { SmuleUtil, Util } from "./util";
import { SmuleUrls } from "./smule-urls";
import { CategorySongsRequest, LoginAsGuestRequest, LoginRefreshRequest, LoginRequest, PerformancesByUserRequest, PerformancesListRequest, SongbookRequest } from "./smule-requests";

class InvalidParametersError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "InvalidParametersError"
    }
}
class NotImplementedError extends Error {
    constructor(message: string) {
        super(message)
        this.name = "NotImplementedError"
    }
}

/**
 * Namespace for Smule's digest parameter found in http requests
 * 
 * Basically, it takes in certain "required" parameters, the body,
 * and a few more pieces of data, alongside the path; concatenates them
 * together, prepends a static salt, and then creates a sha1 digest
 */
export namespace SmuleDigest {
    const SALT = `c2250918de500e32c37842f2d25d4d8210992a0ae96a7f36c4c9703cc675d02b92968bc4fa7feada`
    export function _calculateDigest(encodedPath: string, digestParameters: string): string {
        const shasum = crypto.createHash("sha1")
        return shasum.update(SALT + encodedPath + digestParameters).digest("hex")
    }
    function _getDigestParameters(
        parameters: {[key: string]: string},
        needsSession = false,
        isGetRequest = false, 
        multiPartBody: string = "",
    ) {
        let neededParameters = {}
        let required = ["appVersion", "app", "appVariant", "msgId"]
        if (needsSession) required.push("session")

        for (let param of required) {
            if (!parameters[param])
                throw new InvalidParametersError(`Missing parameter ${param}`)
            
            neededParameters[param] = parameters[param]
        }
        if (parameters["ftrack"]) neededParameters["ftrack"] = parameters["ftrack"]
        
        if (isGetRequest) {
            for (let param of Object.keys(parameters)) {
                neededParameters[param] = parameters[param]
            }
        }
        if (multiPartBody != "") {
            // TODO: handle multipart digest
        }

        return neededParameters
    }
    function _runDigestCalculation(
        parameters: {[key: string]: string},
        urlPath: string,
        body = ""
    ) {
        let tempString = ""
        for (let name of Object.keys(parameters).sort()) {
            tempString += name + parameters[name]
        }
        if (body != "") tempString += body

        // console.log(urlPath, tempString, body)
        return _calculateDigest(urlPath, tempString)
    }

    /**
     * Calculates the SHA1 digest required for
     * HTTP requests to smule's api
     * 
     * @param urlPath The path of the request
     * @param parameters The query parameters of the request
     * @param body The body of the request
     * @param needsSession Whether or not session is required for this request
     * @param isGetRequest Whether or not this is a GET request
     * @param isMultiPartBody Whether or not the body is multipart
     * @returns SHA1 digest
     */
    export function calculateDigest(
        urlPath: string,
        parameters: {[key: string]: string}|URLSearchParams,
        body = "",
        needsSession = false,
        isGetRequest = false,
        isMultiPartBody = false
    ) {
        if (parameters instanceof URLSearchParams) parameters = Util.queryToObject(parameters)
        urlPath = Util.getPathFromFullUrl(urlPath)
        let digestParameters = _getDigestParameters(parameters, needsSession, isGetRequest, isMultiPartBody ? body : "")
        return _runDigestCalculation(digestParameters, urlPath, body)
    }
}

//#region Logging
function _log(...args: any) {
    console.log("[SmuleAPI]",...args)
}
function _warn(...args: any) {
    console.warn("[SmuleAPI]",...args)
}
function _error(...args: any) {
    console.error("[SmuleAPI]",...args)
}
//#endregion

/**
 * The public interface for Smule's API
 */
export class Smule {
    session = new SmuleSession()
    private msgId = 1000
    private ax = axios.create({
        validateStatus: () => true
    })
    
    constructor() {}


    
    /**
     * @returns Whether or not the request has been successful 
     */
    private _handleNon200(response: AxiosResponse): boolean {
        if (response.status == 200) {
            let data: ApiResponse<any> = response.data
            if (data.status.code == 0) return true
            else {
                _warn(`[${response.request.path}] Got ${data.status.code} - ${data.status.message ?? SmuleErrorCode[data.status.code]}`)
                _warn(data)
                _warn(response.config.data)
                return false
            }
        }
        
        if (response.request && response.request.path) {
            _warn(`[${response.request.path}] Got ${response.status} - ${response.statusText}`)
            _warn(response.data)
        } else {
            _warn(`[NO REQUEST?] Got ${response.status} - ${response.statusText}`)
            _warn(response.data)
        }
        return false
    }
    private async _createRequest(url: string, body: any, isJson = true, isGetRequest = false, checkSession = true) {
        let params = new URLSearchParams()
        params.append("app", "sing_google")
        params.append("appVariant", "1")
        params.append("appVersion", "11.8.5")
        params.append("msgId", this.msgId.toString())
        if (this.session && this.session.sessionToken && !this.session.expired) {
            params.append("session", this.session.sessionToken)
        } 

        if (typeof body == "object") body = JSON.stringify(body)

        let digest = SmuleDigest.calculateDigest(url, params, body, checkSession && params.has("session"), isGetRequest, isJson)
        params.append("digest", digest)

        let headers = {
            "Accept-Encoding": "gzip",
            "Connection": "keep-alive",
            "Content-Type": isJson ? "application/json" : "", // TODO
            "User-Agent": "com.smule.singandroid/11.8.5 (9,SM-S908E,en_US)"
        }

        this.msgId++
        
        if (isJson) {
            return this.ax.post(url + `?${params.toString()}`, body, {
                headers,
            })
        } else {
            throw new NotImplementedError("TODO: handle non-JSON and GET requests")
        }
    }
    private _getResponseData<T>(response: AxiosResponse) {
        let data = response.data as ApiResponse<T>
        return data.data as T
    }

    /**
     * Logs in as a guest
     * @returns Whether or not the login was successful
     */
    public async loginAsGuest() {
        let req = await this._createRequest(SmuleUrls.LoginGuest, new LoginAsGuestRequest()) 
        if (!this._handleNon200(req)) return false
        
        let res = this._getResponseData<LoginAsGuestResult>(req)
        //* Guests do not receive a refresh token
        this.session.sessionToken = res.loginResult.sessionToken
        this.session.isGuest = true
        this.session.expired = false

        _log(`Logged in as player ID ${res.loginResult.playerId} (GUEST)`)
        return true
    }
    /**
     * Look up a user by their email
     * 
     * Usually used for login, but who cares lol
     * @param email The email adress the user utilizes for their account
     * @returns The user's data
     */
    public async lookUpUserByEmail(email: string) {
        let req = await this._createRequest(SmuleUrls.UserLookup, {email}, true, false, false)
        if (!this._handleNon200(req)) return false
        return this._getResponseData<{accountIcon: AccountIcon, apps: string[]}>(req)
    }
    /**
     * Look up multiple accounts
     * @param accountIds An array of the accounts' IDs
     * @returns The accounts' details
     */
    public async lookUpUsersByIds(accountIds: number[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch accounts.")
            return
        }

        let req = await this._createRequest(SmuleUrls.AccountLookup, {accountIds})
        if (!this._handleNon200(req)) return
        return this._getResponseData<UsersLookupResult>(req)
    }
    /**
     * Looks up a single account
     * @param accountId The account's id
     * @returns The account's details
     */
    public async lookUpUserById(accountId: number) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch accounts.")
            return
        }
        
        let data = await this.lookUpUsersByIds([accountId])
        return data!.accountIcons[0]
    }
    /**
     * Log into your account
     * @param email Your email address
     * @param password Your smule account's password
     * @returns Whether the log in was successful
     */
    public async login(email: string, password: string) {
        let req = await this._createRequest(SmuleUrls.UserLogin, new LoginRequest(email, password), true, false, false)
        if (!this._handleNon200(req)) return false
        let res = this._getResponseData<LoginResult>(req)
        this.session.sessionToken = res.sessionToken
        this.session.refreshToken = res.refreshToken
        this.session.expired = false
        _log(`Logged in as ${res.handle} (${res.playerId})`)
        return true
    }
    

    /**
     * Refreshes the session token
     * @returns Whether or not the refresh was successful
     */
    public async refreshLogin() {
        if (!this.session.isGuest) {
            _error("Guests are not allowed to refresh their login.")
            return false
        }
        if (!this.session.refreshToken) {
            _error("Requested to refresh login but no refresh token found. Did you even log in?")
            return false
        }
        if (!this.session.expired) {
            _warn("Refreshing login although session isnt expired?")
            this.session.expired = true // Must be expired in order to refresh
        }
    
        let req = await this._createRequest(SmuleUrls.LoginRefresh, new LoginRefreshRequest(this.session.refreshToken), true, false, false)
        if (!this._handleNon200(req)) return false

        let res = this._getResponseData<{loginResult: LoginResult}>(req)

        this.session.sessionToken = res.loginResult.sessionToken
        this.session.refreshToken = res.loginResult.refreshToken
        this.session.expired = false
        
        _log(`Refreshed login with player ID ${res.loginResult.playerId}`)
        return true
    }

    private isLoggedIn() {
        return SmuleUtil.checkLoggedIn(this.session)
    }


    /**
     * Fetch recommended songs, which appear on the front page
     * @param cursor Paging
     * @param limit How many per page
     * @returns The "song book"
     */
    public async getSongBook(cursor = "start", limit = 10) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to get a song book.")
            return
        }

        let req = await this._createRequest(this.session.isGuest ? SmuleUrls.SongbookGuest : SmuleUrls.Songbook, new SongbookRequest(cursor, limit))
        if (!this._handleNon200(req)) return
        return this._getResponseData<SongbookResult>(req)
    }

    /**
     * Fetch songs from a certain category
     * @param cursor Paging
     * @param categoryId The category's id
     * @param limit How many per page
     * @returns The songs
     */
    public async getSongsFromCategory(cursor = "start", categoryId = 9998, limit = 10) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch songs.")
            return
        }

        let req = await this._createRequest(SmuleUrls.Category, new CategorySongsRequest(cursor, limit, categoryId))
        if (!this._handleNon200(req)) return
        return this._getResponseData<CategorySongsResult>(req)
    }


    /**
     * Look up multiple performances at once
     * @param performanceKeys An array of performance keys
     * @returns The performances' details
     */
    public async lookUpPerformancesByKeys(performanceKeys: string[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceByKeys, {performanceKeys})
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformanceByKeysResult>(req)
    }
    /**
     * Looks up a single performance
     * @param performanceKey The performance key
     * @returns The performance's details
     */
    public async lookUpPerformanceByKey(performanceKey: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let data = await this.lookUpPerformancesByKeys([performanceKey])
        return data!.performanceIcons[0]
    }
    /**
     * Look up performances by a specific user
     * 
     * @param accountId The account ID of the user whose performances are to be fetched
     * @param limit The maximum number of performances to fetch (default is 20)
     * @param offset The starting point for fetching performances (default is 0)
     * @returns The user's performances details
     */
    public async lookUpPerformancesByUser(accountId: number, limit = 20, offset = 0) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceParts, new PerformancesByUserRequest(accountId, limit, offset))
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformancesByUserResult>(req)
    }
    /**
     * Retrieves a list of performances based on the specified criteria.
     * 
     * @param sort The order in which to sort the performances (default is SUGGESTED).
     * @param fillStatus The fill status of the performances (default is ACTIVESEED).
     * @param limit The maximum number of performances to fetch (default is 20).
     * @param offset The starting point for fetching performances (default is 0).
     * @returns An object containing an array of performance icons and the next offset.
     */
    public async listPerformances(sort = PerformancesSortOrder.SUGGESTED, fillStatus = PerformancesFillStatus.ACTIVESEED, limit = 20, offset = 0) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceList, new PerformancesListRequest(sort, fillStatus, limit, offset))
        if (!this._handleNon200(req)) return
        return this._getResponseData<PerformanceList>(req)
    }
    /**
     * Retrieves a list of performances based on the specified criteria.
     * 
     * @param requests An array of PerformanceReq objects. Each object contains the criteria for fetching performances.
     * @returns An object containing an array of performance lists.
     */
    public async requestListsOfPerformances(requests: PerformanceReq[]) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch performances.")
            return
        }

        let req = await this._createRequest(SmuleUrls.PerformanceLists, {perfRequests: requests})
        if (!this._handleNon200(req)) return
        return this._getResponseData<{perfLists: PerformanceList[]}>(req)
    }

    /**
     * Fetches a song using the specified key.
     * 
     * @param key The key associated with the song to be fetched.
     * @returns The details of the song
     */
    public async fetchSong(key: string) {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch a song.")
            return
        }

        let req = await this._createRequest(SmuleUrls.Arr, {arrKey: key})
        if (!this._handleNon200(req)) return
        return this._getResponseData<ArrResult>(req)
    }

    /**
     * Fetches your profile
     * @returns Your profile
     */
    public async fetchSelf() {
        if (!this.isLoggedIn()) {
            _error("You must be logged in in order to fetch yourself.")
            return
        }
        if (this.session.isGuest) {
            _error("You must be logged in as a user in order to fetch yourself.")
            return
        }

        let req = await this._createRequest(SmuleUrls.UserProfileMe, {includeActiveState: false})
        if (!this._handleNon200(req)) return
        return this._getResponseData<ProfileResult>(req)
    }
}

//TODO: finish this lol
export namespace SmuleMIDI {
    export enum SmuleUserSinging {
        BOTH,
        PART_ONE,
        PART_TWO,
    }
    export type SmuleLyrics = {
        text: string,
        startTime: number,
        endTime: number,
        singPart: SmuleUserSinging
    }
    function cleanLyric(lyric: string) {
        return lyric.replaceAll("\\n", "")
            .replaceAll("â", "'")
    }
    export function fetchLyricsFromMIDI(midi: string|Uint8Array): SmuleLyrics[] {
        let midiArr: MidiFile = midiParser.parse(midi)
        let multiplier = 500_000 / (midiArr.timeDivision * 1_000_000)
        
        //TODO: Maybe give up on enums and just search for the track itself?
        //TODO: Although, the smule app itself uses constant values for these,
        //TODO: in some cases... Who knows :3

        //TODO: Test this out for groups too, since i've only tested duets

        let rawLyrics = []
        let rawSections = {}
        for (let track of midiArr.track) {
            //* Skip timing track
            //TODO: eventually use this to properly calculate timing
            if (track.event[0].type == 0x58) continue
            if (track.event[0].type != 0xff) continue // skip non meta-started tracks

            let trackName = track.event[0].data
            if (trackName == "Lyrics") {
                let currentTime = 0;
                for (let event of track.event) {
                    if (event.metaType != 0x05) continue // skip non-lyric events
                    currentTime += event.deltaTime * multiplier
                    rawLyrics.push({
                        text: cleanLyric(event.data as string),
                        time: currentTime,
                        deltaTime: event.deltaTime * multiplier,
                    })
                }
            } else if (trackName == "Sections") {
                let currentTime = 0;
                for (let event of track.event) {
                    if (event.type != 0x9 && event.type != 0x8) continue // skip non-note events
                    currentTime += event.deltaTime * multiplier

                    if (rawSections[currentTime] == null) {
                        rawSections[currentTime] = {
                            on: [],
                            off: []
                        }
                    }
                    rawSections[currentTime][event.type == 9 ? "on" : "off"].push(event.data[0])
                }
            }
        }

        if (!rawLyrics || !rawSections) {
            console.warn("[SmuleMIDI] No lyrics or sections found in MIDI file. Are you sure we have lyrics?")
        }
        
        let lyrics = []
        for (let lyric of rawLyrics) {
            let section = rawSections[lyric.time]
            let nextSectionTime = null
            for (let [time, _] of Object.entries(rawSections)) {
                if (Number(time) > lyric.time) {
                    nextSectionTime = time
                    break
                }
            }
            if (!section) {
                console.warn(`[SmuleMIDI] No section found for lyric at time ${lyric.time}. Skipping.`)
                continue
            }
            if (!nextSectionTime) {
                console.warn(`[SmuleMIDI] No ending section found for lyric at time ${lyric.time}? We will assume ending time...`)
            }
            
            let userSinging = SmuleUserSinging.PART_ONE
            if (section.on.includes(50)) {
                if (section.on.includes(51)) {
                    userSinging = SmuleUserSinging.PART_TWO
                } else {
                    userSinging = SmuleUserSinging.PART_ONE
                }
            } else {
                userSinging = SmuleUserSinging.BOTH
            }

            lyrics.push({
                text: lyric.text,
                startTime: lyric.time,
                endTime: lyric.time + lyric.deltaTime,
                singPart: userSinging
            })
        }

        return lyrics
    } 
}